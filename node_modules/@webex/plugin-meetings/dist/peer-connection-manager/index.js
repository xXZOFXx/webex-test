'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _bowser = require('bowser');

var _bowser2 = _interopRequireDefault(_bowser);

var _sdpTransform = require('sdp-transform');

var _sdpTransform2 = _interopRequireDefault(_sdpTransform);

var _metrics = require('../metrics');

var _metrics2 = _interopRequireDefault(_metrics);

var _loggerProxy = require('../common/logs/logger-proxy');

var _loggerProxy2 = _interopRequireDefault(_loggerProxy);

var _config = require('../common/config');

var _config2 = _interopRequireDefault(_config);

var _constants = require('../constants');

var _config3 = require('../metrics/config');

var _media = require('../common/errors/media');

var _media2 = _interopRequireDefault(_media);

var _parameter = require('../common/errors/parameter');

var _parameter2 = _interopRequireDefault(_parameter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @export
 * @public
 */
var pc = {};

/**
 * munges the bandwidth limit into the sdp
 * @param {String} sdpLines
 * @param {Number} index
 * @returns {String}
 */
// https://github.com/clux/sdp-transform

/* eslint-disable */
// We need to figure out how to pass a webex logger instance to these util files

/* globals window, RTCSessionDescription */

var insertBandwidthLimit = function insertBandwidthLimit(sdpLines, index) {
  // eslint-disable-next-line no-warning-comments
  // TODO convert to sdp parser
  var limit = void 0;
  if (sdpLines[index].search(_constants.AUDIO) !== -1) {
    limit = _config2.default.meetings.bandwidth.audio;
  } else {
    limit = _config2.default.meetings.bandwidth.video;
  }
  sdpLines.splice(index + 1, 0, _constants.SDP.B_LINE + ':' + limit);
  return sdpLines;
};

/**
 * needed for calliope max-fs
 * @param {String} sdp
 * @param {String} [level=QUALITY_LEVELS.HIGH] quality level for max-fs
 * @returns {String}
 */
var setMaxFs = function setMaxFs(sdp) {
  var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _constants.QUALITY_LEVELS.HIGH;

  if (!_constants.MAX_FRAMESIZES[level]) {
    throw new _parameter2.default('setMaxFs: unable to set max framesize, value for level "' + level + '" is not defined');
  }
  // eslint-disable-next-line no-warning-comments
  // TODO convert with sdp parser, no munging
  var replaceSdp = sdp;
  var maxFsLine = '' + _constants.SDP.MAX_FS + _constants.MAX_FRAMESIZES[level];
  replaceSdp = replaceSdp.replace(/(\na=fmtp:(\d+).*level-asymmetry-allowed=1.*)/gi, '$1;' + maxFsLine);
  return replaceSdp;
};

/**
 * checks that sdp has h264 codec in it
 * @param {String} sdp
 * @returns {boolean}
 */
var checkH264Support = function checkH264Support(sdp) {
  // eslint-disable-next-line no-warning-comments
  // TODO convert to sdp parser to read rtp.codec
  var videoPresent = sdp.match(/\nm=video.*/g);
  var h264Present = sdp.match(/\na=rtpmap:\d+\sH264.*/g);
  if (videoPresent) {
    return !!h264Present;
  }
  return true;
};

/**
 * validates the sdp, checks port, candidates, and ice info
 * @param {String} sdp
 * @returns {Boolean}
 */
var validateSdp = function validateSdp(sdp) {
  var parsedSdp = _sdpTransform2.default.parse(sdp);
  parsedSdp.media.forEach(function (mediaLine) {
    if (mediaLine.candidates && mediaLine.candidates.length === 0) {
      _loggerProxy2.default.logger.error('PeerConnectionManager:index#validateSdp --> iceCandidate: Ice candadate never completed');
      return false;
    }
    if (_constants.SDP.BAD_MEDIA_PORTS.includes(mediaLine.port)) {
      _loggerProxy2.default.logger.error('PeerConnectionManager:index#validateSdp --> iceCandidate: Found invalid port number for the ice candidate');
      return false;
    }
    if (!mediaLine.icePwd || !mediaLine.iceUfrag) {
      _loggerProxy2.default.logger.error('PeerConnectionManager:index#validateSdp --> iceCandidate: ice ufrag and password not found');
      return false;
    }
    return true;
  });
};

/**
 * munges the bandwidth into the sdp
 * @param {String} sdp
 * @returns {String}
 */
var limitBandwidth = function limitBandwidth(sdp) {
  // TODO convert to sdp parser
  var offerSdp = sdp;
  var sdpLines = offerSdp.split(_constants.SDP.CARRIAGE_RETURN);

  for (var i = 0; i < sdpLines.length; i += 1) {
    if (sdpLines[i].search(_constants.SDP.M_LINE) !== -1) {
      sdpLines = insertBandwidthLimit(sdpLines, i);
    }
  }
  offerSdp = sdpLines.join(_constants.SDP.CARRIAGE_RETURN);
  return offerSdp;
};

/**
 * makes sure the screen pc sdp has content:slides for server
 * @param {RTCPeerConnection} screenPC
 * @returns {RTCPeerConnection}
 */
pc.setContentSlides = function (screenPc) {
  if (screenPc && screenPc.sdp) {
    screenPc.sdp += '' + _constants.SDP.A_CONTENT_SLIDES + _constants.SDP.CARRIAGE_RETURN;
  }
  return screenPc;
};

/**
 * handles ice trickling and establishes ICE connection onto peer connection object
 * @param {Object} peerConnection
 * @param {Object} options
 * @param {String} options.remoteQualityLevel
 * @returns {RTCPeerConnection}
 */
pc.iceCandidate = function (peerConnection, _ref) {
  var remoteQualityLevel = _ref.remoteQualityLevel;
  return new _promise2.default(function (resolve) {
    // TODO: we dont need timeout as we can check the api state and validate.
    var timeout = setTimeout(function () {
      peerConnection.sdp = limitBandwidth(peerConnection.localDescription.sdp);
      peerConnection.sdp = setMaxFs(peerConnection.sdp, remoteQualityLevel);
      peerConnection.sdp = peerConnection.sdp.replace(/\na=extmap.*/g, '');

      if (!validateSdp(peerConnection.sdp)) {
        setTimeout(function () {
          resolve(peerConnection);
        }, _constants.RETRY_TIMEOUT);
      } else {
        resolve(peerConnection);
      }
    }, _constants.ICE_TIMEOUT);

    peerConnection.onicecandidate = function (evt) {
      if (!evt.candidate && !peerConnection.sdp) {
        peerConnection.sdp = limitBandwidth(peerConnection.localDescription.sdp);
        peerConnection.sdp = setMaxFs(peerConnection.sdp, remoteQualityLevel);
        peerConnection.sdp = peerConnection.sdp.replace(/\na=extmap.*/g, '');

        if (evt.candidate === null) {
          validateSdp(peerConnection.sdp);
          clearTimeout(timeout);
          resolve(peerConnection);
        }
      }
    };
  });
};

/**
 * swapping tracks
 * @param {Object} peerConnection
 * @param {Object} track
 * @returns {undefined}
 */
pc.replaceTrack = function (peerConnection, track) {
  try {
    var senders = peerConnection.getSenders();
    if (senders.length > 0) {
      senders.forEach(function (sender) {
        if (sender.track && sender.track.kind === track.kind) {
          sender.replaceTrack(track);
        }
      });
    }
  } catch (err) {
    _loggerProxy2.default.logger.error('PeerConnectionManager:index#replaceTrack --> Error replacing track, ' + err);
  }
};

/**
 * adding streams to peerConnection
 * @param {Object} peerConnection
 * @param {Object} stream
 * @returns {undefined}
 */
pc.addStream = function (peerConnection, stream) {
  try {
    if (stream && !_bowser2.default.msedge) {
      var tracksPresent = peerConnection.getSenders && peerConnection.getSenders().find(function (sender) {
        return sender.track != null;
      });
      if (tracksPresent) {
        stream.getTracks().forEach(function (track) {
          pc.replaceTrack(peerConnection, track);
        });
        return;
      }
      stream.getTracks().forEach(function (track) {
        peerConnection.addTrack(track, stream);
      });
      // // TODO : may come back disable addTracks for chrome they are moving back to addStream
      // // https://bugs.chromium.org/p/chromium/issues/detail?id=764414
      // // https://bugs.chromium.org/p/chromium/issues/detail?id=738918#c7
      //   peerConnection.addStream(stream);
    } else if (_bowser2.default.msedge) {
      peerConnection.addStream(stream);
    } else {}
  } catch (err) {
    _loggerProxy2.default.logger.error('PeerConnectionManager:index#addStream --> Error adding stream, error: ' + _config3.error);
  }
};

/**
 * setting the remote description
 * @param {Object} peerConnection
 * @param {String} typeStr
 * @param {String} remoteSdp
 * @param {String} meetingId
 * @returns {undefined}
 */
pc.setRemoteSessionDetails = function (peerConnection, typeStr, remoteSdp, meetingId) {
  _loggerProxy2.default.logger.log('PeerConnectionManager:index#setRemoteSessionDetails --> Setting the remote description type: ' + typeStr + 'State: ' + peerConnection.signalingState);
  var sdp = remoteSdp;

  sdp = sdp.replace(/\na=extmap.*/g, '');

  // making sure that the remoteDescription is only set when there is a answer for offer
  // or there is a offer from the server

  if (!sdp) {
    _metrics2.default.postEvent({
      event: _config3.eventType.REMOTE_SDP_RECEIVED,
      meetingId: meetingId, data: {
        canProceed: false,
        errors: [_metrics2.default.generateErrorPayload(2001, true, _config3.error.name.MEDIA_ENGINE, 'missing remoteSdp')]
      } });
  }
  if (peerConnection.signalingState === _constants.SDP.HAVE_LOCAL_OFFER || peerConnection.signalingState === _constants.SDP.STABLE && typeStr === _constants.SDP.OFFER) {
    return peerConnection.setRemoteDescription(new window.RTCSessionDescription({
      type: typeStr,
      sdp: sdp
    })).then(function () {
      return _metrics2.default.postEvent({
        event: _config3.eventType.REMOTE_SDP_RECEIVED,
        meetingId: meetingId });
    }).catch(function (error) {
      _loggerProxy2.default.logger.error('Peer-connection-manager:index#setRemoteDescription --> ' + error + ' missing remotesdp');
      return _metrics2.default.postEvent({
        event: _config3.eventType.REMOTE_SDP_RECEIVED,
        meetingId: meetingId,
        data: {
          canProceed: false,
          errors: [_metrics2.default.generateErrorPayload(2001, true, error.name.MEDIA_ENGINE, 'missing remoteSdp')]
        }
      });
    });
  }

  return _promise2.default.reject(new _media2.default('PeerConnection in wrong state'));
};

/**
 * create offer with a valid paramater
 * @param {Object} params
 * @param {Object} meetingProperties
 * @param {string} meetingProperties.meetingId
 * @param {string} meetingProperties.remoteQualityLevel LOW|MEDIUM|HIGH
 * @returns {RTCPeerConnection}
 */
pc.createOffer = function (peerConnection, _ref2) {
  var meetingId = _ref2.meetingId,
      remoteQualityLevel = _ref2.remoteQualityLevel;

  _loggerProxy2.default.logger.log('PeerConnectionManager:index#createOffer --> creating a new offer');

  return peerConnection.createOffer().then(function (description) {
    // bug https://bugs.chromium.org/p/chromium/issues/detail?id=1020642
    // chrome currently generates RTX line irrespective of weither the server side supports it
    // we are removing apt as well because its associated with rtx line

    description.sdp = description.sdp.replace(/\r\na=rtpmap:\d+ rtx\/\d+/g, '');
    description.sdp = description.sdp.replace(/\r\na=fmtp:\d+ apt=\d+/g, '');
    peerConnection.setLocalDescription(description);
  }).then(function () {
    return pc.iceCandidate(peerConnection, { remoteQualityLevel: remoteQualityLevel });
  }).then(function () {
    peerConnection.sdp = limitBandwidth(peerConnection.localDescription.sdp);
    peerConnection.sdp = setMaxFs(peerConnection.sdp, remoteQualityLevel);
    if (!checkH264Support(peerConnection.sdp)) {
      throw new _media2.default('openH264 is downloading please Wait. Upload logs if not working on second try');
    }
    peerConnection.sdp = peerConnection.sdp.replace(/\na=extmap.*/g, '');
    pc.setContentSlides(peerConnection);

    _metrics2.default.postEvent({
      event: _config3.eventType.LOCAL_SDP_GENERATED,
      meetingId: meetingId
    });
    return peerConnection;
  }).catch(function (err) {
    _loggerProxy2.default.logger.error('Peer-connection-manager:index#createOffer --> ' + err);
    _metrics2.default.postEvent({
      event: _config3.eventType.LOCAL_SDP_GENERATED,
      meetingId: meetingId,
      data: {
        canProceed: false,
        errors: [_metrics2.default.generateErrorPayload(2001, true, _config3.error.name.MEDIA_ENGINE)]
      } });
    pc.close(peerConnection);
    throw err;
  });
};

/**
 * rollBack local description in peerconnection
 * @param {Object} peerConnection
 * @returns {RTCPeerConnection}
 */
pc.rollBackLocalDescription = function (peerConnection) {
  return peerConnection.setLocalDescription(new RTCSessionDescription({ type: _constants.SDP.ROLLBACK })).then(function () {
    return peerConnection;
  }).catch(function (err) {
    _loggerProxy2.default.logger.error('Peer-connection-manager:index#setLocalDescription --> ' + err + ' ');
    return _promise2.default.error(err);
  });
};

/**
 * @param {Object} params {
 * @param {Boolean} params.offerToReceiveAudio
 * @param {Boolean} params.offerToReceiveVideo
 * @param {string} params.offerSdp
 * @param {MediaStream} params.stream
 * @param {Object} meetingProperties
 * @param {string} meetingProperties.meetingId
 * @param {string} meetingProperties.remoteQualityLevel LOW|MEDIUM|HIGH
 * @returns {Promise.<Array>} [MediaSDP, ScreenSDP]
 */
pc.updatePeerConnection = function (params, _ref3) {
  var meetingId = _ref3.meetingId,
      remoteQualityLevel = _ref3.remoteQualityLevel;

  _loggerProxy2.default.logger.log('PeerConnectionManager:index#updatePeerConnection --> updating the peerConnection with params: ' + params);

  var peerConnection = params.peerConnection,
      offerSdp = params.offerSdp;


  return pc.createAnswer({
    peerConnection: peerConnection,
    offerSdp: offerSdp[0]
  }, { meetingId: meetingId, remoteQualityLevel: remoteQualityLevel }).then(function (peerconnection) {
    // The content slides should also be set when we are sending inactive
    pc.setContentSlides(peerconnection);
    return _promise2.default.resolve([peerconnection.sdp]);
  });
};

/**
 * @param {Object} params
 * @param {Object} params.peerConnection
 * @param {Object} params.sdpConstraints
 * @param {Object} meetingProperties
 * @param {string} meetingProperties.meetingId
 * @param {string} meetingProperties.remoteQualityLevel LOW|MEDIUM|HIGH
 * @returns {RTCPeerConnection} peerConnection
 */
pc.createAnswer = function (params, _ref4) {
  var meetingId = _ref4.meetingId,
      remoteQualityLevel = _ref4.remoteQualityLevel;
  var peerConnection = params.peerConnection;

  // TODO: Some times to many mercury event comes at the same time
  // Need to maintain state of peerconnection

  if (peerConnection.signalingState === _constants.SDP.HAVE_REMOTE_OFFER) {
    return _promise2.default.resolve(peerConnection);
  }

  return pc.setRemoteSessionDetails(peerConnection, _constants.OFFER, params.offerSdp, meetingId).then(function () {
    return peerConnection.createAnswer(params.sdpConstraints);
  }).then(function (answer) {
    return (
      //   if (edonusHack()) {
      //     answer.sdp = answer.sdp.replace(/recvonly.*/g, 'sendrecv');
      //   }
      peerConnection.setLocalDescription(answer)
    );
  }).then(function () {
    return pc.iceCandidate(peerConnection, { remoteQualityLevel: remoteQualityLevel });
  }).then(function () {
    peerConnection.sdp = limitBandwidth(peerConnection.localDescription.sdp);
    peerConnection.sdp = setMaxFs(peerConnection.sdp, remoteQualityLevel);
    if (!checkH264Support(peerConnection.sdp)) {
      throw new _media2.default('openH264 is downloading please Wait. Upload logs if not working on second try');
    }

    peerConnection.sdp = peerConnection.sdp.replace(/\na=extmap.*/g, '');

    return peerConnection;
  }).catch(function (err) {
    _loggerProxy2.default.logger.error('PeerConnectionManager:index#setRemoteSessionDetails --> Error creating remote session, error: ' + _config3.error);
  });
};

/**
 * shut down the peer connection
 * @param {Object} peerConnection
 * @returns {undefined}
 */
pc.close = function (peerConnection) {
  // peerConnection.close() fails on firefox on network changes and gives a Dom exception
  // To avoid this we have added a try catch block.
  // Please refer to https://bugzilla.mozilla.org/show_bug.cgi?id=1274407 for more information

  if (peerConnection && peerConnection.connectionState === _constants.PEER_CONNECTION_STATE.CLOSED) {
    return _promise2.default.resolve();
  }
  _loggerProxy2.default.logger.log('PeerConnectionManager:index#close --> pc: close() -> closing the mediaPeerConnection');
  return _promise2.default.resolve().then(function () {
    if (peerConnection && peerConnection.close) {
      peerConnection.close();
    }
  });
};

pc.setPeerConnectionEvents = function (meeting) {
  // In case ICE fail
  var peerConnection = meeting.mediaProperties.peerConnection;


  var connectionFailed = function connectionFailed() {
    if (meeting.reconnectionManager.iceState.resolve) {
      // DISCONNECTED state triggers first then it goes to FAILED STATE
      // sometimes the failed state can happen before 10 seconds (Which is the timer for the reconnect for ice disconnect)
      meeting.reconnectionManager.iceState.resolve();
    }

    meeting.reconnect({ networkDisconnect: true });
    _metrics2.default.postEvent({
      event: _config3.eventType.ICE_END,
      meeting: meeting,
      data: {
        canProceed: false,
        errors: [_metrics2.default.generateErrorPayload(2004, false, _config3.error.name.MEDIA_ENGINE)]
      }
    });
  };

  peerConnection.oniceconnectionstatechange = function () {
    _loggerProxy2.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> ICE STATE CHANGE.');
    switch (peerConnection.iceConnectionState) {
      case _constants.ICE_STATE.CHECKING:
        _loggerProxy2.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> ICE STATE CHECKING.');
        _metrics2.default.postEvent({ event: _config3.eventType.ICE_START, meeting: meeting });
        break;
      case _constants.ICE_STATE.COMPLETED:
        _loggerProxy2.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> ICE STATE COMPLETED.');
        break;
      case _constants.ICE_STATE.CONNECTED:
        // Ice connection state goes to connected when both client and server sends STUN packets and
        // Established connected between them. Firefox does not trigger COMPLETED and only trigger CONNECTED
        _metrics2.default.postEvent({ event: _config3.eventType.ICE_END, meeting: meeting });
        meeting.setNetworkStatus(_constants.NETWORK_STATUS.CONNECTED);
        meeting.reconnectionManager.iceReconnected();
        _loggerProxy2.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> ICE STATE CONNECTED.');
        break;
      case _constants.ICE_STATE.CLOSED:
        _loggerProxy2.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> ICE STATE CLOSED.');
        break;
      case _constants.ICE_STATE.DISCONNECTED:
        meeting.setNetworkStatus(_constants.NETWORK_STATUS.DISCONNECTED);
        meeting.reconnectionManager.waitForIceReconnect().catch(function () {
          _loggerProxy2.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> ICE STATE DISCONNECTED. Automatic Reconnection Timed Out.');

          connectionFailed();
        });
        _loggerProxy2.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> ICE STATE DISCONNECTED.');
        break;
      case _constants.ICE_STATE.FAILED:
        _loggerProxy2.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> ICE STATE FAILED.');
        // notify of ice failure
        // Ice failure is the only indicator currently for identifying the actual connection drop
        // Firefox takes sometime 10-15 seconds to go to failed state
        connectionFailed();
        break;
      default:
        break;
    }
  };

  peerConnection.onconnectionstatechange = function () {
    _loggerProxy2.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> CONNECTION STATE CHANGE.');
    switch (peerConnection.connectionState) {
      case _constants.CONNECTION_STATE.NEW:
        _loggerProxy2.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> CONNECTION STATE NEW.');
        break;
      case _constants.CONNECTION_STATE.CONNECTING:
        _loggerProxy2.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> CONNECTION STATE CONNECTING.');
        break;
      case _constants.CONNECTION_STATE.CONNECTED:
        _loggerProxy2.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> CONNECTION STATE CONNECTED.');
        break;
      case _constants.CONNECTION_STATE.CLOSED:
        _loggerProxy2.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> CONNECTION STATE CLOSED.');
        break;
      case _constants.CONNECTION_STATE.DISCONNECTED:
        _loggerProxy2.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> CONNECTION STATE DISCONNECTED.');
        break;
      case _constants.CONNECTION_STATE.FAILED:
        _loggerProxy2.default.logger.info('PeerConnectionManager:index#setPeerConnectionEvents --> CONNECTION STATE FAILED.');
        // Special case happens only on chrome where there is no ICE FAILED event
        // only CONNECTION FAILED event gets triggred

        connectionFailed();
        break;
      default:
        break;
    }
  };
};

exports.default = pc;
//# sourceMappingURL=index.js.map
