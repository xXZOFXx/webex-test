{"version":3,"sources":["index.js"],"names":["NeedsRetryError","Error","ReconnectionManager","meeting","iceState","disconnected","resolve","timer","undefined","timeoutDuration","config","reconnection","iceReconnectionTimeout","status","RECONNECTION","STATE","DEFAULT_STATUS","tryCount","DEFAULT_TRY_COUNT","webex","maxRejoinAttempts","rejoinAttempts","reset","LoggerProxy","logger","log","clearTimeout","reject","setTimeout","enabled","COMPLETE","info","ReconnectInProgress","ReconnectionError","networkDisconnect","validate","Metrics","postEvent","event","eventType","MEDIA_RECONNECTING","executeReconnection","then","MEDIA_RECOVERED","data","recoveredBy","RECOVERED_BY_NEW","catch","reconnectError","reconnect","error","MEDIA_RECONNECTION_FAILED","IN_PROGRESS","reconnectMercuryWebSocket","FAILURE","rejoinMeeting","wasSharing","isSharing","meetings","syncMeetings","state","_LEFT_","join","reconnectMedia","media","Media","stopTracks","mediaProperties","shareTrack","mediaDirection","sendShare","Trigger","trigger","file","function","EVENT_TRIGGERS","MEETING_STOPPED_SHARING_LOCAL","reason","SHARE_STOPPED_REASON","MEETING_REJOIN","setupPeerConnection","attachMedia","meetingId","id","remoteQualityLevel","peerConnection","setRemoteStream","roap","sendRoapMediaRequest","sdp","roapSeq","internal","mercury","connected","disconnect","connect","PeerConnectionManager","close","unsetPeerConnection","reInitiatePeerconnection","setPeerConnectionEvents","statsAnalyzer","updatePeerconnection"],"mappings":"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","file":"index.js","sourcesContent":["/*!\n * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.\n */\n\n/* eslint-disable no-warning-comments */\n\nimport LoggerProxy from '../common/logs/logger-proxy';\nimport Trigger from '../common/events/trigger-proxy';\nimport {\n  EVENT_TRIGGERS, RECONNECTION, SHARE_STOPPED_REASON, _LEFT_\n} from '../constants';\nimport ReconnectionError from '../common/errors/reconnection';\nimport ReconnectInProgress from '../common/errors/reconnection-in-progress';\nimport PeerConnectionManager from '../peer-connection-manager';\nimport {eventType, reconnection} from '../metrics/config';\nimport Media from '../media';\nimport Metrics from '../metrics';\n\n/**\n * Used to indicate that the reconnect logic needs to be retried.\n *\n * @class NeedsRetryError\n * @extends {Error}\n */\nclass NeedsRetryError extends Error {}\n\n/**\n * @export\n * @class ReconnectionManager\n*/\nexport default class ReconnectionManager {\n  /**\n   * @param {Meeting} meeting\n   */\n  constructor(meeting) {\n    /**\n     * Stores ICE reconnection state data.\n     *\n     * @instance\n     * @type {Object}\n     * @private\n     * @memberof ReconnectionManager\n     */\n    this.iceState = {\n      disconnected: false,\n      resolve: () => {},\n      timer: undefined,\n      timeoutDuration: meeting.config.reconnection.iceReconnectionTimeout\n    };\n\n    /**\n     * @instance\n     * @type {String}\n     * @private\n     * @memberof ReconnectionManager\n    */\n    this.status = RECONNECTION.STATE.DEFAULT_STATUS;\n    /**\n     * @instance\n     * @type {Number}\n     * @private\n     * @memberof ReconnectionManager\n    */\n    this.tryCount = RECONNECTION.STATE.DEFAULT_TRY_COUNT;\n    /**\n     * @instance\n     * @type {Object}\n     * @private\n     * @memberof ReconnectionManager\n    */\n    this.webex = meeting.webex;\n    /**\n     * @instance\n     * @type {Meeting}\n     * @private\n     * @memberof ReconnectionManager\n     */\n    this.meeting = meeting;\n\n    this.maxRejoinAttempts = meeting.config.reconnection.maxRejoinAttempts;\n    this.rejoinAttempts = RECONNECTION.STATE.DEFAULT_TRY_COUNT;\n\n\n    // Make sure reconnection state is in default\n    this.reset();\n  }\n\n  /**\n   * Sets the iceState to connected and clears any disconnect timeouts and\n   * related timeout data within the iceState.\n   *\n   * @returns {undefined}\n   * @public\n   * @memberof ReconnectionManager\n   */\n  iceReconnected() {\n    if (this.iceState.disconnected) {\n      LoggerProxy.logger.log('ReconnectionManager:index#iceReconnected --> ice has reconnected');\n\n      this.iceState.resolve();\n      this.iceState.resolve = () => {};\n\n      if (this.iceState.timer) {\n        clearTimeout(this.iceState.timer);\n        delete this.iceState.timer;\n      }\n\n      this.iceState.disconnected = false;\n    }\n  }\n\n  /**\n   * Set the iceState to disconnected and generates a timeout that waits for the\n   * iceState to reconnect and then resolves. If the ice state is already\n   * processing a reconnect, it immediately resolves. Rejects if the timeout\n   * duration is reached.\n   *\n   * @returns {Promise<undefined>}\n   * @public\n   * @memberof ReconnectionManager\n   */\n  waitForIceReconnect() {\n    if (!this.iceState.disconnected) {\n      LoggerProxy.logger.log('ReconnectionManager:index#waitForIceReconnect --> waiting for ice reconnect');\n\n      this.iceState.disconnected = true;\n\n      return new Promise((resolve, reject) => {\n        this.iceState.timer = setTimeout(() => {\n          if (this.iceState.disconnected === false) {\n            resolve();\n          }\n          else {\n            this.iceState.disconnected = false;\n            reject(new Error(`ice reconnection did not occur in ${this.iceState.timeoutDuration}ms`));\n          }\n        }, this.iceState.timeoutDuration);\n\n        this.iceState.resolve = resolve;\n      });\n    }\n\n    // return a resolved promise to prevent multiple catch executions of reconnect\n    return Promise.resolve();\n  }\n\n  /**\n   * @returns {undefined}\n   * @public\n   * @memberof ReconnectionManager\n   */\n  reset() {\n    this.status = RECONNECTION.STATE.DEFAULT_STATUS;\n    this.tryCount = RECONNECTION.STATE.DEFAULT_TRY_COUNT;\n    this.rejoinAttempts = RECONNECTION.STATE.DEFAULT_TRY_COUNT;\n  }\n\n  /**\n   * @returns {Boolean}\n   * @throws {ReconnectionError}\n   * @private\n   * @memberof ReconnectionManager\n   */\n  validate() {\n    if (this.meeting.config.reconnection.enabled) {\n      if (\n        this.status === RECONNECTION.STATE.DEFAULT_STATUS ||\n        this.status === RECONNECTION.STATE.COMPLETE\n      ) {\n        return true;\n      }\n\n      LoggerProxy.logger.info('ReconnectionManager:index#validate --> Reconnection already in progress.');\n\n      throw new ReconnectInProgress('Reconnection already in progress.');\n    }\n\n    LoggerProxy.logger.info('ReconnectionManager:index#validate --> Reconnection is not enabled.');\n\n    throw new ReconnectionError('Reconnection is not enabled.');\n  }\n\n  /**\n   * Initiates a media reconnect for the active meeting\n   * @param {Object} reconnectOptions\n   * @param {boolean} [reconnectOptions.networkDisconnect=false] indicates if a network disconnect event happened\n   * @returns {Promise}\n   * @public\n   * @memberof ReconnectionManager\n   */\n  async reconnect({networkDisconnect = false} = {}) {\n    LoggerProxy.logger.info('ReconnectionManager:index#reconnect --> Reconnection start.');\n    // First, validate that we can reconnect, if not, it will throw an error\n    try {\n      this.validate();\n    }\n    catch (error) {\n      LoggerProxy.logger.info('ReconnectionManager:index#reconnect --> Reconnection unable to begin.', error);\n      throw error;\n    }\n\n    Metrics.postEvent({\n      event: eventType.MEDIA_RECONNECTING,\n      meeting: this.meeting\n    });\n\n    return this.executeReconnection({networkDisconnect})\n      .then(() => {\n        LoggerProxy.logger.info('ReconnectionManager:index#reconnect --> Reconnection successful.');\n        Metrics.postEvent({\n          event: eventType.MEDIA_RECOVERED,\n          meeting: this.meeting,\n          data: {recoveredBy: reconnection.RECOVERED_BY_NEW}\n        });\n      })\n      .catch((reconnectError) => {\n        if (reconnectError instanceof NeedsRetryError) {\n          LoggerProxy.logger.info('ReconnectionManager:index#reconnect --> Reconnection not successful, retrying.');\n          // Reset our reconnect status since we are looping back to the beginning\n          this.status = RECONNECTION.STATE.DEFAULT_STATUS;\n\n          return this.reconnect({networkDisconnect: true});\n        }\n\n        LoggerProxy.logger.error('ReconnectionManager:index#reconnect --> Reconnection failed.', reconnectError);\n        Metrics.postEvent({\n          event: eventType.MEDIA_RECONNECTION_FAILED,\n          meeting: this.meeting\n        });\n\n        throw reconnectError;\n      });\n  }\n\n  /**\n   * @param {Object} reconnectOptions\n   * @param {boolean} [reconnectOptions.networkDisconnect=false] indicates if a network disconnect event happened\n   * @returns {Promise}\n   * @throws {NeedsRetryError}\n   * @private\n   * @memberof ReconnectionManager\n   */\n  async executeReconnection({networkDisconnect = false}) {\n    this.status = RECONNECTION.STATE.IN_PROGRESS;\n\n    LoggerProxy.logger.info('ReconnectionManager:index#executeReconnection --> Attempting to reconnect to meeting.');\n\n    if (networkDisconnect) {\n      try {\n        await this.reconnectMercuryWebSocket();\n      }\n      catch (error) {\n        // TODO: Add Metrics for Reconnect Failed\n        LoggerProxy.logger.error('ReconnectionManager:index#executeReconnection --> Unable to reconnect to websocket, giving up.');\n        this.status = RECONNECTION.STATE.FAILURE;\n        throw (error);\n      }\n    }\n\n    let rejoinMeeting = false;\n    const wasSharing = this.meeting.isSharing;\n\n    try {\n      LoggerProxy.logger.info('ReconnectionManager:index#executeReconnection --> Updating meeting data from server.');\n      await this.webex.meetings.syncMeetings();\n    }\n    catch (syncError) {\n      LoggerProxy.logger.info('ReconnectionManager:index#executeReconnection --> Unable to sync meetings, reconnecting.', syncError);\n      throw (new NeedsRetryError(syncError));\n    }\n\n    if (this.meeting.state === _LEFT_) {\n      try {\n        rejoinMeeting = true;\n\n        await this.meeting.join();\n      }\n      catch (joinError) {\n        this.rejoinAttempts += 1;\n        if (this.rejoinAttempts <= this.maxRejoinAttempts) {\n          LoggerProxy.logger.info('ReconnectionManager:index#executeReconnection --> Unable to rejoin meeting, reconnecting.', joinError);\n          throw (new NeedsRetryError(joinError));\n        }\n        else {\n          LoggerProxy.logger.error('ReconnectionManager:index#executeReconnection --> Unable to rejoin meeting after max attempts.', joinError);\n          this.status = RECONNECTION.STATE.FAILURE;\n          throw joinError;\n        }\n      }\n    }\n\n    try {\n      const media = await this.reconnectMedia();\n\n      LoggerProxy.logger.log('ReconnectionManager:index#executeReconnection --> Media reestablished');\n      this.status = RECONNECTION.STATE.COMPLETE;\n      if (rejoinMeeting && wasSharing) {\n        // Stop the share streams if user tried to rejoin\n        Media.stopTracks(this.meeting.mediaProperties.shareTrack);\n        this.meeting.isSharing = false;\n        this.meeting.mediaProperties.mediaDirection.sendShare = false;\n        Trigger.trigger(\n          this.meeting,\n          {\n            file: 'reconnection-manager/index',\n            function: 'executeReconnection'\n          },\n          EVENT_TRIGGERS.MEETING_STOPPED_SHARING_LOCAL,\n          {\n            reason: SHARE_STOPPED_REASON.MEETING_REJOIN\n          }\n        );\n      }\n\n      return media;\n    }\n    catch (error) {\n      // TODO: Add Metrics for Reconnect Failed\n      LoggerProxy.logger.error('ReconnectionManager:index#executeReconnection --> Media reestablishment failed');\n      this.status = RECONNECTION.STATE.FAILURE;\n\n      throw (error);\n    }\n  }\n\n  /**\n   * @param {Meeting} meeting\n   * @returns {Promise}\n   * @private\n   * @memberof ReconnectionManager\n   */\n  reconnectMedia() {\n    LoggerProxy.logger.log('ReconnectionManager:index#reconnectMedia --> Begin reestablishment of media');\n\n    ReconnectionManager.setupPeerConnection(this.meeting);\n\n    return Media.attachMedia(this.meeting.mediaProperties, {\n      meetingId: this.meeting.id,\n      remoteQualityLevel: this.meeting.mediaProperties.remoteQualityLevel\n    })\n      .then((peerConnection) => this.meeting.setRemoteStream(peerConnection))\n      .then(() => this.meeting.roap\n        .sendRoapMediaRequest({\n          sdp: this.meeting.mediaProperties.peerConnection.sdp,\n          roapSeq: this.meeting.roapSeq,\n          meeting: this.meeting,\n          reconnect: true // Need to check if its a reconnect after rejoin or media inactivity\n        }));\n  }\n\n  /**\n   * Attempt to Reconnect Mercury Websocket\n   * @returns {Promise}\n   * @private\n   * @memberof ReconnectionManager\n   */\n  async reconnectMercuryWebSocket() {\n    LoggerProxy.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Reconnecting websocket.');\n    // First, attempt to disconnect if we think we are already connected.\n    if (this.webex.internal.mercury.connected) {\n      LoggerProxy.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Disconnecting existing websocket.');\n      try {\n        await this.webex.internal.mercury.disconnect();\n        LoggerProxy.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Websocket disconnected successfully.');\n      }\n      catch (disconnectError) {\n        // If we can't disconnect, the sdk is in such a bad state that reconnecting is not going to happen.\n        LoggerProxy.logger.error('ReconnectionManager:index#reconnectMercuryWebSocket --> Unable to disconnect to websocket, giving up.', disconnectError);\n        throw disconnectError;\n      }\n    }\n\n    try {\n      LoggerProxy.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Connecting websocket.');\n      await this.webex.internal.mercury.connect();\n      LoggerProxy.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Websocket connected successfully.');\n    }\n    catch (connectError) {\n      LoggerProxy.logger.error('ReconnectionManager:index#reconnectMercuryWebSocket --> Unable to connect to websocket, giving up.', connectError);\n\n      throw (connectError);\n    }\n  }\n\n  /**\n   * @param {Meeting} meeting\n   * @returns {undefined}\n   * @private\n   * @memberof ReconnectionManager\n   */\n  static setupPeerConnection(meeting) {\n    // close pcs, unset to null and create a new one with out closing any streams\n    PeerConnectionManager.close(meeting.mediaProperties.peerConnection);\n    meeting.mediaProperties.unsetPeerConnection();\n    meeting.mediaProperties.reInitiatePeerconnection();\n    PeerConnectionManager.setPeerConnectionEvents(meeting);\n    // update the peerconnection in the stats manager when ever we reconnect\n    meeting.statsAnalyzer.updatePeerconnection(meeting.mediaProperties.peerConnection);\n  }\n}\n"]}