'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _create = require('babel-runtime/core-js/object/create');

var _create2 = _interopRequireDefault(_create);

var _setPrototypeOf = require('babel-runtime/core-js/object/set-prototype-of');

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _construct = require('babel-runtime/core-js/reflect/construct');

var _construct2 = _interopRequireDefault(_construct);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _loggerProxy = require('../common/logs/logger-proxy');

var _loggerProxy2 = _interopRequireDefault(_loggerProxy);

var _triggerProxy = require('../common/events/trigger-proxy');

var _triggerProxy2 = _interopRequireDefault(_triggerProxy);

var _constants = require('../constants');

var _reconnection = require('../common/errors/reconnection');

var _reconnection2 = _interopRequireDefault(_reconnection);

var _reconnectionInProgress = require('../common/errors/reconnection-in-progress');

var _reconnectionInProgress2 = _interopRequireDefault(_reconnectionInProgress);

var _peerConnectionManager = require('../peer-connection-manager');

var _peerConnectionManager2 = _interopRequireDefault(_peerConnectionManager);

var _config = require('../metrics/config');

var _media = require('../media');

var _media2 = _interopRequireDefault(_media);

var _metrics = require('../metrics');

var _metrics2 = _interopRequireDefault(_metrics);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    var instance = (0, _construct2.default)(cls, (0, _from2.default)(arguments));
    (0, _setPrototypeOf2.default)(instance, (0, _getPrototypeOf2.default)(this));
    return instance;
  }

  ExtendableBuiltin.prototype = (0, _create2.default)(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (_setPrototypeOf2.default) {
    (0, _setPrototypeOf2.default)(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }

  return ExtendableBuiltin;
} /*!
   * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
   */

/* eslint-disable no-warning-comments */

/**
 * Used to indicate that the reconnect logic needs to be retried.
 *
 * @class NeedsRetryError
 * @extends {Error}
 */
var NeedsRetryError = function (_extendableBuiltin2) {
  (0, _inherits3.default)(NeedsRetryError, _extendableBuiltin2);

  function NeedsRetryError() {
    (0, _classCallCheck3.default)(this, NeedsRetryError);
    return (0, _possibleConstructorReturn3.default)(this, (NeedsRetryError.__proto__ || (0, _getPrototypeOf2.default)(NeedsRetryError)).apply(this, arguments));
  }

  return NeedsRetryError;
}(_extendableBuiltin(Error));

/**
 * @export
 * @class ReconnectionManager
*/


var ReconnectionManager = function () {
  /**
   * @param {Meeting} meeting
   */
  function ReconnectionManager(meeting) {
    (0, _classCallCheck3.default)(this, ReconnectionManager);

    /**
     * Stores ICE reconnection state data.
     *
     * @instance
     * @type {Object}
     * @private
     * @memberof ReconnectionManager
     */
    this.iceState = {
      disconnected: false,
      resolve: function resolve() {},
      timer: undefined,
      timeoutDuration: meeting.config.reconnection.iceReconnectionTimeout
    };

    /**
     * @instance
     * @type {String}
     * @private
     * @memberof ReconnectionManager
    */
    this.status = _constants.RECONNECTION.STATE.DEFAULT_STATUS;
    /**
     * @instance
     * @type {Number}
     * @private
     * @memberof ReconnectionManager
    */
    this.tryCount = _constants.RECONNECTION.STATE.DEFAULT_TRY_COUNT;
    /**
     * @instance
     * @type {Object}
     * @private
     * @memberof ReconnectionManager
    */
    this.webex = meeting.webex;
    /**
     * @instance
     * @type {Meeting}
     * @private
     * @memberof ReconnectionManager
     */
    this.meeting = meeting;

    this.maxRejoinAttempts = meeting.config.reconnection.maxRejoinAttempts;
    this.rejoinAttempts = _constants.RECONNECTION.STATE.DEFAULT_TRY_COUNT;

    // Make sure reconnection state is in default
    this.reset();
  }

  /**
   * Sets the iceState to connected and clears any disconnect timeouts and
   * related timeout data within the iceState.
   *
   * @returns {undefined}
   * @public
   * @memberof ReconnectionManager
   */


  (0, _createClass3.default)(ReconnectionManager, [{
    key: 'iceReconnected',
    value: function iceReconnected() {
      if (this.iceState.disconnected) {
        _loggerProxy2.default.logger.log('ReconnectionManager:index#iceReconnected --> ice has reconnected');

        this.iceState.resolve();
        this.iceState.resolve = function () {};

        if (this.iceState.timer) {
          clearTimeout(this.iceState.timer);
          delete this.iceState.timer;
        }

        this.iceState.disconnected = false;
      }
    }

    /**
     * Set the iceState to disconnected and generates a timeout that waits for the
     * iceState to reconnect and then resolves. If the ice state is already
     * processing a reconnect, it immediately resolves. Rejects if the timeout
     * duration is reached.
     *
     * @returns {Promise<undefined>}
     * @public
     * @memberof ReconnectionManager
     */

  }, {
    key: 'waitForIceReconnect',
    value: function waitForIceReconnect() {
      var _this2 = this;

      if (!this.iceState.disconnected) {
        _loggerProxy2.default.logger.log('ReconnectionManager:index#waitForIceReconnect --> waiting for ice reconnect');

        this.iceState.disconnected = true;

        return new _promise2.default(function (resolve, reject) {
          _this2.iceState.timer = setTimeout(function () {
            if (_this2.iceState.disconnected === false) {
              resolve();
            } else {
              _this2.iceState.disconnected = false;
              reject(new Error('ice reconnection did not occur in ' + _this2.iceState.timeoutDuration + 'ms'));
            }
          }, _this2.iceState.timeoutDuration);

          _this2.iceState.resolve = resolve;
        });
      }

      // return a resolved promise to prevent multiple catch executions of reconnect
      return _promise2.default.resolve();
    }

    /**
     * @returns {undefined}
     * @public
     * @memberof ReconnectionManager
     */

  }, {
    key: 'reset',
    value: function reset() {
      this.status = _constants.RECONNECTION.STATE.DEFAULT_STATUS;
      this.tryCount = _constants.RECONNECTION.STATE.DEFAULT_TRY_COUNT;
      this.rejoinAttempts = _constants.RECONNECTION.STATE.DEFAULT_TRY_COUNT;
    }

    /**
     * @returns {Boolean}
     * @throws {ReconnectionError}
     * @private
     * @memberof ReconnectionManager
     */

  }, {
    key: 'validate',
    value: function validate() {
      if (this.meeting.config.reconnection.enabled) {
        if (this.status === _constants.RECONNECTION.STATE.DEFAULT_STATUS || this.status === _constants.RECONNECTION.STATE.COMPLETE) {
          return true;
        }

        _loggerProxy2.default.logger.info('ReconnectionManager:index#validate --> Reconnection already in progress.');

        throw new _reconnectionInProgress2.default('Reconnection already in progress.');
      }

      _loggerProxy2.default.logger.info('ReconnectionManager:index#validate --> Reconnection is not enabled.');

      throw new _reconnection2.default('Reconnection is not enabled.');
    }

    /**
     * Initiates a media reconnect for the active meeting
     * @param {Object} reconnectOptions
     * @param {boolean} [reconnectOptions.networkDisconnect=false] indicates if a network disconnect event happened
     * @returns {Promise}
     * @public
     * @memberof ReconnectionManager
     */

  }, {
    key: 'reconnect',
    value: function () {
      var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
        var _this3 = this;

        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref2$networkDisconne = _ref2.networkDisconnect,
            networkDisconnect = _ref2$networkDisconne === undefined ? false : _ref2$networkDisconne;

        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _loggerProxy2.default.logger.info('ReconnectionManager:index#reconnect --> Reconnection start.');
                // First, validate that we can reconnect, if not, it will throw an error
                _context.prev = 1;

                this.validate();
                _context.next = 9;
                break;

              case 5:
                _context.prev = 5;
                _context.t0 = _context['catch'](1);

                _loggerProxy2.default.logger.info('ReconnectionManager:index#reconnect --> Reconnection unable to begin.', _context.t0);
                throw _context.t0;

              case 9:

                _metrics2.default.postEvent({
                  event: _config.eventType.MEDIA_RECONNECTING,
                  meeting: this.meeting
                });

                return _context.abrupt('return', this.executeReconnection({ networkDisconnect: networkDisconnect }).then(function () {
                  _loggerProxy2.default.logger.info('ReconnectionManager:index#reconnect --> Reconnection successful.');
                  _metrics2.default.postEvent({
                    event: _config.eventType.MEDIA_RECOVERED,
                    meeting: _this3.meeting,
                    data: { recoveredBy: _config.reconnection.RECOVERED_BY_NEW }
                  });
                }).catch(function (reconnectError) {
                  if (reconnectError instanceof NeedsRetryError) {
                    _loggerProxy2.default.logger.info('ReconnectionManager:index#reconnect --> Reconnection not successful, retrying.');
                    // Reset our reconnect status since we are looping back to the beginning
                    _this3.status = _constants.RECONNECTION.STATE.DEFAULT_STATUS;

                    return _this3.reconnect({ networkDisconnect: true });
                  }

                  _loggerProxy2.default.logger.error('ReconnectionManager:index#reconnect --> Reconnection failed.', reconnectError);
                  _metrics2.default.postEvent({
                    event: _config.eventType.MEDIA_RECONNECTION_FAILED,
                    meeting: _this3.meeting
                  });

                  throw reconnectError;
                }));

              case 11:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this, [[1, 5]]);
      }));

      function reconnect() {
        return _ref.apply(this, arguments);
      }

      return reconnect;
    }()

    /**
     * @param {Object} reconnectOptions
     * @param {boolean} [reconnectOptions.networkDisconnect=false] indicates if a network disconnect event happened
     * @returns {Promise}
     * @throws {NeedsRetryError}
     * @private
     * @memberof ReconnectionManager
     */

  }, {
    key: 'executeReconnection',
    value: function () {
      var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(_ref3) {
        var _ref3$networkDisconne = _ref3.networkDisconnect,
            networkDisconnect = _ref3$networkDisconne === undefined ? false : _ref3$networkDisconne;
        var rejoinMeeting, wasSharing, media;
        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.status = _constants.RECONNECTION.STATE.IN_PROGRESS;

                _loggerProxy2.default.logger.info('ReconnectionManager:index#executeReconnection --> Attempting to reconnect to meeting.');

                if (!networkDisconnect) {
                  _context2.next = 13;
                  break;
                }

                _context2.prev = 3;
                _context2.next = 6;
                return this.reconnectMercuryWebSocket();

              case 6:
                _context2.next = 13;
                break;

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2['catch'](3);

                // TODO: Add Metrics for Reconnect Failed
                _loggerProxy2.default.logger.error('ReconnectionManager:index#executeReconnection --> Unable to reconnect to websocket, giving up.');
                this.status = _constants.RECONNECTION.STATE.FAILURE;
                throw _context2.t0;

              case 13:
                rejoinMeeting = false;
                wasSharing = this.meeting.isSharing;
                _context2.prev = 15;

                _loggerProxy2.default.logger.info('ReconnectionManager:index#executeReconnection --> Updating meeting data from server.');
                _context2.next = 19;
                return this.webex.meetings.syncMeetings();

              case 19:
                _context2.next = 25;
                break;

              case 21:
                _context2.prev = 21;
                _context2.t1 = _context2['catch'](15);

                _loggerProxy2.default.logger.info('ReconnectionManager:index#executeReconnection --> Unable to sync meetings, reconnecting.', _context2.t1);
                throw new NeedsRetryError(_context2.t1);

              case 25:
                if (!(this.meeting.state === _constants._LEFT_)) {
                  _context2.next = 43;
                  break;
                }

                _context2.prev = 26;

                rejoinMeeting = true;

                _context2.next = 30;
                return this.meeting.join();

              case 30:
                _context2.next = 43;
                break;

              case 32:
                _context2.prev = 32;
                _context2.t2 = _context2['catch'](26);

                this.rejoinAttempts += 1;

                if (!(this.rejoinAttempts <= this.maxRejoinAttempts)) {
                  _context2.next = 40;
                  break;
                }

                _loggerProxy2.default.logger.info('ReconnectionManager:index#executeReconnection --> Unable to rejoin meeting, reconnecting.', _context2.t2);
                throw new NeedsRetryError(_context2.t2);

              case 40:
                _loggerProxy2.default.logger.error('ReconnectionManager:index#executeReconnection --> Unable to rejoin meeting after max attempts.', _context2.t2);
                this.status = _constants.RECONNECTION.STATE.FAILURE;
                throw _context2.t2;

              case 43:
                _context2.prev = 43;
                _context2.next = 46;
                return this.reconnectMedia();

              case 46:
                media = _context2.sent;


                _loggerProxy2.default.logger.log('ReconnectionManager:index#executeReconnection --> Media reestablished');
                this.status = _constants.RECONNECTION.STATE.COMPLETE;
                if (rejoinMeeting && wasSharing) {
                  // Stop the share streams if user tried to rejoin
                  _media2.default.stopTracks(this.meeting.mediaProperties.shareTrack);
                  this.meeting.isSharing = false;
                  this.meeting.mediaProperties.mediaDirection.sendShare = false;
                  _triggerProxy2.default.trigger(this.meeting, {
                    file: 'reconnection-manager/index',
                    function: 'executeReconnection'
                  }, _constants.EVENT_TRIGGERS.MEETING_STOPPED_SHARING_LOCAL, {
                    reason: _constants.SHARE_STOPPED_REASON.MEETING_REJOIN
                  });
                }

                return _context2.abrupt('return', media);

              case 53:
                _context2.prev = 53;
                _context2.t3 = _context2['catch'](43);

                // TODO: Add Metrics for Reconnect Failed
                _loggerProxy2.default.logger.error('ReconnectionManager:index#executeReconnection --> Media reestablishment failed');
                this.status = _constants.RECONNECTION.STATE.FAILURE;

                throw _context2.t3;

              case 58:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this, [[3, 8], [15, 21], [26, 32], [43, 53]]);
      }));

      function executeReconnection(_x2) {
        return _ref4.apply(this, arguments);
      }

      return executeReconnection;
    }()

    /**
     * @param {Meeting} meeting
     * @returns {Promise}
     * @private
     * @memberof ReconnectionManager
     */

  }, {
    key: 'reconnectMedia',
    value: function reconnectMedia() {
      var _this4 = this;

      _loggerProxy2.default.logger.log('ReconnectionManager:index#reconnectMedia --> Begin reestablishment of media');

      ReconnectionManager.setupPeerConnection(this.meeting);

      return _media2.default.attachMedia(this.meeting.mediaProperties, {
        meetingId: this.meeting.id,
        remoteQualityLevel: this.meeting.mediaProperties.remoteQualityLevel
      }).then(function (peerConnection) {
        return _this4.meeting.setRemoteStream(peerConnection);
      }).then(function () {
        return _this4.meeting.roap.sendRoapMediaRequest({
          sdp: _this4.meeting.mediaProperties.peerConnection.sdp,
          roapSeq: _this4.meeting.roapSeq,
          meeting: _this4.meeting,
          reconnect: true // Need to check if its a reconnect after rejoin or media inactivity
        });
      });
    }

    /**
     * Attempt to Reconnect Mercury Websocket
     * @returns {Promise}
     * @private
     * @memberof ReconnectionManager
     */

  }, {
    key: 'reconnectMercuryWebSocket',
    value: function () {
      var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _loggerProxy2.default.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Reconnecting websocket.');
                // First, attempt to disconnect if we think we are already connected.

                if (!this.webex.internal.mercury.connected) {
                  _context3.next = 13;
                  break;
                }

                _loggerProxy2.default.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Disconnecting existing websocket.');
                _context3.prev = 3;
                _context3.next = 6;
                return this.webex.internal.mercury.disconnect();

              case 6:
                _loggerProxy2.default.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Websocket disconnected successfully.');
                _context3.next = 13;
                break;

              case 9:
                _context3.prev = 9;
                _context3.t0 = _context3['catch'](3);

                // If we can't disconnect, the sdk is in such a bad state that reconnecting is not going to happen.
                _loggerProxy2.default.logger.error('ReconnectionManager:index#reconnectMercuryWebSocket --> Unable to disconnect to websocket, giving up.', _context3.t0);
                throw _context3.t0;

              case 13:
                _context3.prev = 13;

                _loggerProxy2.default.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Connecting websocket.');
                _context3.next = 17;
                return this.webex.internal.mercury.connect();

              case 17:
                _loggerProxy2.default.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Websocket connected successfully.');
                _context3.next = 24;
                break;

              case 20:
                _context3.prev = 20;
                _context3.t1 = _context3['catch'](13);

                _loggerProxy2.default.logger.error('ReconnectionManager:index#reconnectMercuryWebSocket --> Unable to connect to websocket, giving up.', _context3.t1);

                throw _context3.t1;

              case 24:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this, [[3, 9], [13, 20]]);
      }));

      function reconnectMercuryWebSocket() {
        return _ref5.apply(this, arguments);
      }

      return reconnectMercuryWebSocket;
    }()

    /**
     * @param {Meeting} meeting
     * @returns {undefined}
     * @private
     * @memberof ReconnectionManager
     */

  }], [{
    key: 'setupPeerConnection',
    value: function setupPeerConnection(meeting) {
      // close pcs, unset to null and create a new one with out closing any streams
      _peerConnectionManager2.default.close(meeting.mediaProperties.peerConnection);
      meeting.mediaProperties.unsetPeerConnection();
      meeting.mediaProperties.reInitiatePeerconnection();
      _peerConnectionManager2.default.setPeerConnectionEvents(meeting);
      // update the peerconnection in the stats manager when ever we reconnect
      meeting.statsAnalyzer.updatePeerconnection(meeting.mediaProperties.peerConnection);
    }
  }]);
  return ReconnectionManager;
}();

exports.default = ReconnectionManager;
//# sourceMappingURL=index.js.map
