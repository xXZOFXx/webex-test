'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _eventsScope = require('../common/events/events-scope');

var _eventsScope2 = _interopRequireDefault(_eventsScope);

var _constants = require('../constants');

var _config = require('../mediaQualityMetrics/config');

var _config2 = _interopRequireDefault(_config);

var _loggerProxy = require('../common/logs/logger-proxy');

var _loggerProxy2 = _interopRequireDefault(_loggerProxy);

var _global = require('./global');

var _global2 = _interopRequireDefault(_global);

var _mqaUtil = require('./mqaUtil');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
  * Meeting High Packet Loss Event
  * Emitted when ever there is high packet loss detected
  * @event meeting:highPacketLoss
  * @type {Object}
  * @property {String} mediaType Type of media experiencing packet loss
  * @property {Number} packetLossRatio current packet loss ratio
  * @memberof StatsAnalyzer
  */

/**
 * Stats Analyzer class that will emit events based on detected quality
 *
 * @export
 * @class StatsAnalyzer
 * @extends {EventsScope}
 */
var StatsAnalyzer = function (_EventsScope) {
  (0, _inherits3.default)(StatsAnalyzer, _EventsScope);

  /**
   * Creates a new instance of StatsAnalyzer
   * @constructor
   * @public
   * @param {Object} config SDK Configuration Object
   */
  function StatsAnalyzer(config) {
    (0, _classCallCheck3.default)(this, StatsAnalyzer);

    var _this = (0, _possibleConstructorReturn3.default)(this, (StatsAnalyzer.__proto__ || (0, _getPrototypeOf2.default)(StatsAnalyzer)).call(this));

    _this.remotecandidate = function (result, type, isSender) {
      if (!result || !result.id) {
        return;
      }
      var RemoteCandidateType = {};
      var RemoteTransport = {};
      var RemoteIpAddress = {};
      var RemoteNetworkType = {};

      if (!result.id) return;

      var sendRecvType = isSender ? 'send' : 'recv';

      if (!RemoteCandidateType[result.id]) {
        RemoteCandidateType[result.id] = [];
      }

      if (!RemoteTransport[result.id]) {
        RemoteTransport[result.id] = [];
      }

      if (!RemoteIpAddress[result.id]) {
        RemoteIpAddress[result.id] = [];
      }
      if (!RemoteNetworkType[result.id]) {
        RemoteNetworkType[result.id] = [];
      }

      if (result.candidateType && RemoteCandidateType[result.id].indexOf(result.candidateType) === 0) {
        RemoteCandidateType[result.id].push(result.candidateType);
      }

      if (result.transport && RemoteTransport[result.id].indexOf(result.transport) === 0) {
        RemoteTransport[result.id].push(result.transport);
      }

      if (result.ipAddress && RemoteIpAddress[result.id].indexOf(result.ipAddress + ':' + result.portNumber) === 0) {
        RemoteIpAddress[result.id].push(result.ipAddress + ':' + result.portNumber);
      }

      if (result.networkType && RemoteNetworkType[result.id].indexOf(result.networkType) === 0) {
        RemoteNetworkType[result.id].push(result.networkType);
      }

      _this.statsResults.internal.candidates[result.id] = {
        candidateType: RemoteCandidateType[result.id],
        ipAddress: RemoteIpAddress[result.id],
        portNumber: result.portNumber,
        networkType: RemoteNetworkType[result.id],
        priority: result.priority,
        transport: RemoteTransport[result.id],
        timestamp: result.timestamp,
        id: result.id,
        type: result.type
      };

      _this.statsResults.connectionType.remote.candidateType = RemoteCandidateType[result.id];
      _this.statsResults.connectionType.remote.ipAddress = RemoteIpAddress[result.id];
      _this.statsResults.connectionType.remote.networkType = RemoteNetworkType[result.id];
      _this.statsResults.connectionType.remote.transport = RemoteTransport[result.id];

      _this.statsResults[type][sendRecvType].totalRoundTripTime = result.totalRoundTripTime;
      _this.statsResults[type][sendRecvType].bytesReceived = result.bytesReceived;
      _this.statsResults[type][sendRecvType].bytesSent = result.bytesSent;
      _this.statsResults[type][sendRecvType].packetsReceived = result.packetsReceived || 0;
      _this.statsResults[type][sendRecvType].packetsSent = result.packetsSent || 0;
      _this.statsResults[type][sendRecvType].currentRoundTripTime = result.currentRoundTripTime;
      _this.statsResults[type][sendRecvType].availableOutgoingBitrate = result.availableOutgoingBitrate;
      _this.statsResults[type][sendRecvType].availableIncomingBitrate = result.availableIncomingBitrate;
    };

    _this.statsResults = _global2.default;
    _this.config = config;
    _this.correlationId = config.correlationId;
    _this.mqaSentCount = 0;
    _this.lastMqaDataSent = {
      resolutions: { video: { send: {}, recv: {} }, audio: { send: {}, recv: {} }, share: { send: {}, recv: {} } },
      video: { send: {}, recv: {} },
      audio: { send: {}, recv: {} },
      share: { send: {}, recv: {} }
    };
    return _this;
  }

  /**
   * captures MQA data from peerconnection
   *
   * @public
   * @memberof StatsAnalyzer
   * @returns {void}
   */


  (0, _createClass3.default)(StatsAnalyzer, [{
    key: 'sendMqaData',
    value: function sendMqaData() {
      var audioReceiver = _config2.default.intervals[0].audioReceive[0];
      var audioSender = _config2.default.intervals[0].audioTransmit[0];
      var videoReceiver = _config2.default.intervals[0].videoReceive[0];
      var videoSender = _config2.default.intervals[0].videoTransmit[0];
      var shareSender = _config2.default.intervals[0].videoTransmit[1];
      var shareReceiver = _config2.default.intervals[0].videoReceive[1];

      (0, _mqaUtil.getAudioSenderMqa)({
        audioSender: audioSender,
        statsResults: this.statsResults,
        lastMqaDataSent: this.lastMqaDataSent
      });
      (0, _mqaUtil.getAudioReceiverMqa)({
        audioReceiver: audioReceiver,
        statsResults: this.statsResults,
        lastMqaDataSent: this.lastMqaDataSent
      });

      (0, _mqaUtil.getVideoReceiverMqa)({
        videoReceiver: videoReceiver,
        statsResults: this.statsResults,
        lastMqaDataSent: this.lastMqaDataSent
      });
      (0, _mqaUtil.getVideoSenderMqa)({
        videoSender: videoSender,
        statsResults: this.statsResults,
        lastMqaDataSent: this.lastMqaDataSent
      });

      // Capture mqa for share scenario

      (0, _mqaUtil.getVideoSenderMqa)({
        videoSender: shareSender,
        statsResults: this.statsResults,
        lastMqaDataSent: this.lastMqaDataSent,
        isShareStream: true
      });

      (0, _mqaUtil.getVideoReceiverMqa)({
        videoReceiver: shareReceiver,
        statsResults: this.statsResults,
        lastMqaDataSent: this.lastMqaDataSent,
        isShareStream: true
      });

      this.mqaSentCount = this.mqaSentCount + 1;

      _config2.default.intervals[0].intervalNumber = this.mqaSentCount;

      // DO Deep copy, for some reason it takes the reference all the time rather then old value set
      this.lastMqaDataSent = JSON.parse((0, _stringify2.default)(this.statsResults));

      this.emit({
        file: 'statsAnalyzer',
        function: 'sendMqaData'
      }, _constants.EVENT_TRIGGERS.MEDIA_QUALITY, _config2.default.intervals[0]);
    }

    /**
     * updated the peerconnection when changed
     *
     * @private
     * @memberof updatePeerconnection
     * @param {PeerConnection} peerConnection
     * @returns {void}
     */

  }, {
    key: 'updatePeerconnection',
    value: function updatePeerconnection(peerConnection) {
      this.peerConnection = peerConnection;
    }

    /**
     * Starts the stats analyzer on interval
     *
     * @public
     * @memberof StatsAnalyzer
     * @param {PeerConnection} peerConnection
     * @returns {void}
     */

  }, {
    key: 'startAnalyzer',
    value: function startAnalyzer(peerConnection) {
      var _this2 = this;

      this.peerConnection = peerConnection;
      this.getStatsAndParse();
      this.statsInterval = setInterval(function () {
        _this2.getStatsAndParse();
      }, this.config.analyzerInterval);
      // Trigger initial fetch
      this.sendMqaData();
      this.mqaInterval = setInterval(function () {
        _this2.sendMqaData();
      }, _constants.MQA_INTEVAL);
    }

    /**
     * Cleans up the analyzer when done
     *
     * @public
     * @memberof StatsAnalyzer
     * @returns {void}
     */

  }, {
    key: 'stopAnalyzer',
    value: function stopAnalyzer() {
      if (this.statsInterval) {
        this.getStatsAndParse();
        clearInterval(this.statsInterval);
        this.statsInterva = undefined;
      }

      if (this.mqaInterval) {
        this.sendMqaData();
        clearInterval(this.mqaInterval);
        this.statsInterva = undefined;
      }
      this.peerConnection = null;
    }

    /**
     * Parse a single result of get stats
     *
     * @private
     * @param {*} getStatsResult
     * @param {String} type
     * @param {boolean} isSender
     * @returns {void}
     * @memberof StatsAnalyzer
     */

  }, {
    key: 'parseGetStatsResult',
    value: function parseGetStatsResult(getStatsResult, type, isSender) {
      if (!getStatsResult) {
        return;
      }

      switch (getStatsResult.type) {
        case 'outbound-rtp':
          this.processOutboundRTPResult(getStatsResult, type);
          break;
        case 'inbound-rtp':
          this.processInboundRTPResult(getStatsResult, type);
          break;
        case 'track':
          this.processTrackResult(getStatsResult, type);
          break;
        case 'remote-inbound-rtp':
        case 'remote-outbound-rtp':
          this.compareSentAndReceived(getStatsResult, type, isSender);
          break;
        case 'remotecandidate':
        case 'remote-candidate':
          this.remotecandidate(getStatsResult, type, isSender);
          break;
        default:
          break;
      }
    }

    /**
     * Filters the get stats results for types
     * @private
     * @param {Array} getStatsResults
     * @param {String} type
     * @param {boolean} isSender
     * @returns {void}
     */

  }, {
    key: 'filterAndParseGetStatsResults',
    value: function filterAndParseGetStatsResults(getStatsResults, type, isSender) {
      var _this3 = this;

      var types = _constants.DEFAULT_GET_STATS_FILTER.types;


      getStatsResults.forEach(function (result) {
        if (types.includes(result.type)) {
          _this3.parseGetStatsResult(result, type, isSender);
        }
      });
    }

    /**
     * Does a `getStats` on all the transceivers and parses the results
     *
     * @private
     * @memberof StatsAnalyzer
     * @returns {void}
     */

  }, {
    key: 'getStatsAndParse',
    value: function getStatsAndParse() {
      var _this4 = this;

      if (!this.peerConnection) {
        return;
      }

      if (this.peerConnection && this.peerConnection.connectionState === _constants.CONNECTION_STATE.FAILED) {
        _loggerProxy2.default.logger.trace('StatsAnalyzer:index#getStatsAndParse --> PeerConnection is in failed state');

        return;
      }
      _loggerProxy2.default.logger.trace('StatsAnalyzer:index#getStatsAndParse --> Collecting Stats');
      this.peerConnection.videoTransceiver.sender.getStats().then(function (res) {
        _this4.filterAndParseGetStatsResults(res, _constants.STATS.VIDEO_CORRELATE, true);
      });

      this.peerConnection.videoTransceiver.receiver.getStats().then(function (res) {
        _this4.filterAndParseGetStatsResults(res, _constants.STATS.VIDEO_CORRELATE, false);
      });

      this.peerConnection.audioTransceiver.sender.getStats().then(function (res) {
        _this4.filterAndParseGetStatsResults(res, _constants.STATS.AUDIO_CORRELATE, true);
      });

      this.peerConnection.audioTransceiver.receiver.getStats().then(function (res) {
        _this4.filterAndParseGetStatsResults(res, _constants.STATS.AUDIO_CORRELATE, false);
      });

      this.peerConnection.shareTransceiver.sender.getStats().then(function (res) {
        _this4.filterAndParseGetStatsResults(res, _constants.STATS.SHARE_CORRELATE, true);
      });

      this.peerConnection.shareTransceiver.receiver.getStats().then(function (res) {
        _this4.filterAndParseGetStatsResults(res, _constants.STATS.SHARE_CORRELATE, false);
      });
      _loggerProxy2.default.logger.trace('StatsAnalyzer:index#getStatsAndParse --> Finished Collecting Stats');
    }

    /**
     * Processes OutboundRTP stats result and stores
     * @private
     * @param {*} result
     * @param {*} type
     * @returns {void}
     */

  }, {
    key: 'processOutboundRTPResult',
    value: function processOutboundRTPResult(result, type) {
      var mediaType = type || 'audio';
      var sendrecvType = 'send';

      if (result.bytesSent) {
        var kilobytes = 0;

        if (!this.statsResults.internal[mediaType][sendrecvType].prevBytesSent) {
          this.statsResults.internal[mediaType][sendrecvType].prevBytesSent = result.bytesSent;
        }
        if (!this.statsResults.internal[mediaType][sendrecvType].framesEncoded) {
          this.statsResults.internal[mediaType][sendrecvType].framesEncoded = result.framesEncoded;
        }
        if (!this.statsResults.internal[mediaType][sendrecvType].keyFramesEncoded) {
          this.statsResults.internal[mediaType][sendrecvType].keyFramesEncoded = result.keyFramesEncoded;
        }

        var bytes = result.bytesSent - this.statsResults.internal[mediaType][sendrecvType].prevBytesSent;

        this.statsResults.internal[mediaType][sendrecvType].prevBytesSent = result.bytesSent;

        kilobytes = bytes / 1024;

        this.statsResults[mediaType][sendrecvType].availableBandwidth = kilobytes.toFixed(1);
        this.statsResults[mediaType].bytesSent = kilobytes;

        this.statsResults[mediaType][sendrecvType].framesEncoded = result.framesEncoded - this.statsResults.internal[mediaType][sendrecvType].framesEncoded;
        this.statsResults[mediaType][sendrecvType].keyFramesEncoded = result.keyFramesEncoded - this.statsResults.internal[mediaType][sendrecvType].keyFramesEncoded;
        this.statsResults.internal[mediaType].outboundRtpId = result.id;

        if (!this.statsResults.internal[mediaType][sendrecvType].packetsSent) {
          this.statsResults.internal[mediaType][sendrecvType].packetsSent = result.packetsSent;
        }

        this.statsResults[mediaType][sendrecvType].packetsSent = result.packetsSent - this.statsResults.internal[mediaType][sendrecvType].packetsSent;
        this.statsResults.internal[mediaType][sendrecvType].packetsSent = result.packetsSent;
        this.statsResults[mediaType][sendrecvType].totalPacketsSent = result.packetsSent;

        if (this.statsResults[mediaType][sendrecvType].packetsSent === 0) {
          _loggerProxy2.default.logger.log('StatsAnalyzer:index#processInboundRTPResult --> No packets sent for ' + mediaType + ' ', this.statsResults[mediaType][sendrecvType].packetsSent);
        }

        // Data saved to send MQA metrics

        this.statsResults[mediaType][sendrecvType].totalKeyFramesEncoded = result.keyFramesEncoded;
        this.statsResults[mediaType][sendrecvType].totalNackCount = result.nackCount;
        this.statsResults[mediaType][sendrecvType].totalPliCount = result.pliCount;
        this.statsResults[mediaType][sendrecvType].totalPacketsSent = result.packetsSent;
        this.statsResults[mediaType][sendrecvType].totalFirCount = result.firCount;
        this.statsResults[mediaType][sendrecvType].framesEncoded = result.framesEncoded;
        this.statsResults[mediaType][sendrecvType].encoderImplementation = result.encoderImplementation;
        this.statsResults[mediaType][sendrecvType].qualityLimitationReason = result.qualityLimitationReason;
        this.statsResults[mediaType][sendrecvType].qualityLimitationResolutionChanges = result.qualityLimitationResolutionChanges;
        this.statsResults[mediaType][sendrecvType].retransmittedPacketsSent = result.retransmittedPacketsSent;
        this.statsResults[mediaType][sendrecvType].totalBytesSent = result.bytesSent;
        this.statsResults[mediaType][sendrecvType].headerBytesSent = result.headerBytesSent;
        this.statsResults[mediaType][sendrecvType].retransmittedBytesSent = result.retransmittedBytesSent;
      }
    }

    /**
     * Processes InboundRTP stats result and stores
     * @private
     * @param {*} result
     * @param {*} type
     * @returns {void}
     */

  }, {
    key: 'processInboundRTPResult',
    value: function processInboundRTPResult(result, type) {
      var mediaType = type || 'audio';
      var sendrecvType = 'recv';

      if (result.bytesReceived) {
        var kilobytes = 0;

        if (!this.statsResults.internal[mediaType][sendrecvType].prevBytesReceived) {
          this.statsResults.internal[mediaType][sendrecvType].prevBytesReceived = result.bytesReceived;
        }

        if (!this.statsResults.internal[mediaType][sendrecvType].pliCount) {
          this.statsResults.internal[mediaType][sendrecvType].pliCount = result.pliCount;
        }

        if (!this.statsResults.internal[mediaType][sendrecvType].packetsLost) {
          this.statsResults.internal[mediaType][sendrecvType].packetsLost = result.packetsLost;
        }

        if (!this.statsResults.internal[mediaType][sendrecvType].totalPacketsReceived) {
          this.statsResults.internal[mediaType][sendrecvType].totalPacketsReceived = result.packetsReceived;
        }

        if (!this.statsResults.internal[mediaType][sendrecvType].lastPacketReceivedTimestamp) {
          this.statsResults.internal[mediaType][sendrecvType].lastPacketReceivedTimestamp = result.lastPacketReceivedTimestamp;
        }

        var bytes = result.bytesReceived - this.statsResults.internal[mediaType][sendrecvType].prevBytesReceived;

        this.statsResults.internal[mediaType][sendrecvType].prevBytesReceived = result.bytesReceived;

        kilobytes = bytes / 1024;
        this.statsResults[mediaType][sendrecvType].availableBandwidth = kilobytes.toFixed(1);
        this.statsResults[mediaType].bytesReceived = kilobytes.toFixed(1);

        this.statsResults[mediaType][sendrecvType].pliCount = result.pliCount - this.statsResults.internal[mediaType][sendrecvType].pliCount;
        this.statsResults[mediaType][sendrecvType].currentPacketsLost = result.packetsLost - this.statsResults.internal[mediaType][sendrecvType].packetsLost;
        if (this.statsResults[mediaType][sendrecvType].currentPacketsLost < 0) {
          this.statsResults[mediaType][sendrecvType].currentPacketsLost = 0;
        }

        this.statsResults[mediaType][sendrecvType].packetsReceived = result.packetsReceived - this.statsResults.internal[mediaType][sendrecvType].totalPacketsReceived;
        this.statsResults.internal[mediaType][sendrecvType].totalPacketsReceived = result.packetsReceived;

        if (this.statsResults[mediaType][sendrecvType].packetsReceived === 0) {
          _loggerProxy2.default.logger.info('StatsAnalyzer:index#processInboundRTPResult --> No packets received for ' + mediaType + ' ', this.statsResults[mediaType][sendrecvType].packetsReceived);
        }

        //  Check the over all packet Lost ratio
        this.statsResults[mediaType][sendrecvType].currentPacketLossRatio = this.statsResults[mediaType][sendrecvType].currentPacketsLost > 0 ? this.statsResults[mediaType][sendrecvType].currentPacketsLost / (this.statsResults[mediaType][sendrecvType].packetsReceived + this.statsResults[mediaType][sendrecvType].currentPacketsLost) : 0;
        if (this.statsResults[mediaType][sendrecvType].currentPacketLossRatio > 3) {
          _loggerProxy2.default.logger.info('StatsAnalyzer:index#processInboundRTPResult --> Packets getting lost from the receiver ', this.statsResults[mediaType][sendrecvType].currentPacketLossRatio);
        }

        this.statsResults[mediaType][sendrecvType].totalPacketsLost = result.packetsLost;
        this.statsResults[mediaType][sendrecvType].lastPacketReceivedTimestamp = result.lastPacketReceivedTimestamp;

        // From Thin
        this.statsResults[mediaType][sendrecvType].totalNackCount = result.nackCount;
        this.statsResults[mediaType][sendrecvType].totalPliCount = result.pliCount;
        this.statsResults[mediaType][sendrecvType].framesDecoded = result.framesDecoded;
        this.statsResults[mediaType][sendrecvType].keyFramesDecoded = result.keyFramesDecoded;
        this.statsResults[mediaType][sendrecvType].decoderImplementation = result.decoderImplementation;
        this.statsResults[mediaType][sendrecvType].totalPacketsReceived = result.packetsReceived;

        this.statsResults[mediaType][sendrecvType].fecPacketsDiscarded = result.fecPacketsDiscarded;
        this.statsResults[mediaType][sendrecvType].fecPackets = result.fecPacketsReceived;
        this.statsResults[mediaType][sendrecvType].totalBytesReceived = result.bytesReceived;
        this.statsResults[mediaType][sendrecvType].headerBytesReceived = result.headerBytesReceived;
        this.statsResults[mediaType][sendrecvType].jitter = result.jitter;
      }
    }

    /**
     * Processes remote candidate result and stores
     * @private
     * @param {*} result
     * @param {*} type
     * @param {boolean} isSender
     *
     * @returns {void}
     */

  }, {
    key: 'processTrackResult',


    /**
     * Process Track results
     *
     * @private
     * @param {*} result
     * @param {*} mediaType
     * @returns {void}
     * @memberof StatsAnalyzer
     */
    value: function processTrackResult(result, mediaType) {
      if (!result || result.type !== 'track') {
        return;
      }
      if (result.type !== 'track') return;

      var sendrecvType = result.remoteSource === true ? 'recv' : 'send';

      if (result.frameWidth && result.frameHeight) {
        this.statsResults.resolutions[mediaType][sendrecvType].width = result.frameWidth;
        this.statsResults.resolutions[mediaType][sendrecvType].height = result.frameHeight;
        this.statsResults.resolutions[mediaType][sendrecvType].framesSent = result.framesSent;
        this.statsResults.resolutions[mediaType][sendrecvType].hugeFramesSent = result.hugeFramesSent;
      }

      if (sendrecvType === 'recv') {
        this.statsResults.resolutions[mediaType][sendrecvType].framesReceived = result.framesReceived;
        this.statsResults.resolutions[mediaType][sendrecvType].framesDecoded = result.framesDecoded;
        this.statsResults.resolutions[mediaType][sendrecvType].framesDropped = result.framesDropped;
      }

      if (result.trackIdentifier && mediaType !== 'audio') {
        this.statsResults.resolutions[mediaType][sendrecvType].trackIdentifier = result.trackIdentifier;

        var jitterBufferDelay = result && result.jitterBufferDelay;
        var jitterBufferEmittedCount = result && result.jitterBufferEmittedCount;

        this.statsResults.resolutions[mediaType][sendrecvType].avgJitterDelay = jitterBufferEmittedCount && +jitterBufferDelay / +jitterBufferEmittedCount;
      }
    }

    /**
     *
     * @private
     * @param {*} result
     * @param {*} type
     * @returns {void}
     * @memberof StatsAnalyzer
     */

  }, {
    key: 'compareSentAndReceived',
    value: function compareSentAndReceived(result, type) {
      if (!type) {
        return;
      }

      var mediaType = type;

      if (!this.statsResults.internal[mediaType].send.totalPacketsLostOnReceiver) {
        this.statsResults.internal[mediaType].send.totalPacketsLostOnReceiver = result.packetsLost;
      }

      var currentPacketLoss = result.packetsLost - this.statsResults.internal[mediaType].send.totalPacketsLostOnReceiver;

      this.statsResults.internal[mediaType].send.totalPacketsLostOnReceiver = result.packetsLost;
      this.statsResults[mediaType].send.packetsLostOnReceiver = currentPacketLoss;
      this.statsResults[mediaType].send.totalPacketsLostOnReceiver = result.packetsLost;
      this.statsResults[mediaType].send.jitter = result.jitter;
      this.statsResults[mediaType].send.roundTripTime = result.roundTripTime;
      this.statsResults[mediaType].send.timestamp = result.timestamp;
      this.statsResults[mediaType].send.ssrc = result.ssrc;
      this.statsResults[mediaType].send.reportsReceived = result.reportsReceived;

      // Total packloss ratio on this video section of the call
      this.statsResults[mediaType].send.overAllPacketLossRatio = this.statsResults[mediaType].send.totalPacketsLostOnReceiver > 0 ? this.statsResults[mediaType].send.totalPacketsLostOnReceiver / this.statsResults[mediaType].send.totalPacketsSent : 0;

      this.statsResults[mediaType].send.currentPacketLossRatio = this.statsResults[mediaType].send.packetsLostOnReceiver > 0 ? this.statsResults[mediaType].send.packetsLostOnReceiver * 100 / (this.statsResults[mediaType].send.packetsSent + this.statsResults[mediaType].send.packetsLostOnReceiver) : 0;

      if (this.statsResults[mediaType].send.maxPacketLossRatio < this.statsResults[mediaType].send.currentPacketLossRatio) {
        this.statsResults[mediaType].send.maxPacketLossRatio = this.statsResults[mediaType].send.currentPacketLossRatio;
      }

      if (this.statsResults[mediaType].send.currentPacketLossRatio > this.config.videoPacketLossRatioThreshold && mediaType === _constants.STATS.VIDEO_CORRELATE) {
        // Trigger downgrade video callback
        _loggerProxy2.default.logger.log('StatsAnalyzer:index#compareSentAndReceived -->  Packet Loss is high ', this.statsResults[mediaType].send.currentPacketLossRatio);
        this.emit({
          file: 'statsAnalyzer',
          function: 'compareSentAndReceived'
        }, _constants.EVENT_TRIGGERS.MEETING_HIGH_PACKETLOSS, {
          mediaType: mediaType,
          packetLossRatio: this.statsResults[mediaType].send.currentPacketLossRatio
        });
      }
    }
  }]);
  return StatsAnalyzer;
}(_eventsScope2.default);

exports.default = StatsAnalyzer;
//# sourceMappingURL=index.js.map
