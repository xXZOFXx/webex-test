'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _peerConnectionManager = require('../peer-connection-manager');

var _peerConnectionManager2 = _interopRequireDefault(_peerConnectionManager);

var _constants = require('../constants');

var _loggerProxy = require('../common/logs/logger-proxy');

var _loggerProxy2 = _interopRequireDefault(_loggerProxy);

var _parameter = require('../common/errors/parameter');

var _parameter2 = _interopRequireDefault(_parameter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RoapUtil = {};
var ROAP_ANSWER = _constants._ANSWER_.toLowerCase();

RoapUtil.shouldHandleMedia = function (meeting) {
  var offer = meeting.mediaProperties.peerConnection && meeting.mediaProperties.peerConnection.signalingState === _constants.SDP.HAVE_LOCAL_OFFER;

  if (offer) {
    return false;
  }

  return true;
};

RoapUtil.handleError = function (pc) {
  return _peerConnectionManager2.default.rollBackLocalDescription({ peerConnection: pc }).then(function () {
    return _promise2.default.resolve(true);
  }).catch(function (err) {
    _loggerProxy2.default.logger.error('Roap:util#handleError --> ' + err);

    return _promise2.default.reject(err);
  });
};

RoapUtil.findError = function (messageType, errorType, type) {
  return (type === _constants.ROAP.RECEIVE_ROAP_MSG || type === _constants.ROAP.SEND_ROAP_MSG) && messageType === _constants._ERROR_ && errorType === _constants._CONFLICT_;
};

RoapUtil.ensureMeeting = function (meeting, type) {
  if (type === _constants.ROAP.RECEIVE_ROAP_MSG || type === _constants.ROAP.SEND_ROAP_MSG || type === _constants.ROAP.SEND_ROAP_MSG_SUCCESS) {
    if (!meeting) {
      return false;
    }
  }

  return true;
};

RoapUtil.updatePeerConnection = function (meeting, session) {
  return _peerConnectionManager2.default.updatePeerConnection({
    offerSdp: session.OFFER.sdps,
    peerConnection: meeting.mediaProperties.peerConnection
  }, {
    meetingId: meeting.id,
    remoteQualityLevel: meeting.mediaProperties.remoteQualityLevel
  }).then(function (res) {
    meeting.roap.lastRoapOffer = session.OFFER.sdps;

    return res;
  });
};

RoapUtil.setRemoteDescription = function (meeting, session) {
  _loggerProxy2.default.logger.info('Roap:util#setRemoteDescription --> Transmit WAIT_TX_OK, correlationId: ' + meeting.correlationId);
  if (!(meeting && meeting.mediaProperties.peerConnection)) {
    _loggerProxy2.default.logger.error('Roap:util#setRemoteDescription --> DANGER no media or screen peer connection, correlationId: ' + meeting.correlationId);

    return _promise2.default.reject(new _parameter2.default('Must provide a media or screen peer connection'));
  }

  return _peerConnectionManager2.default.setRemoteSessionDetails(meeting.mediaProperties.peerConnection, ROAP_ANSWER, session.ANSWER.sdps[0], meeting.id).then(function () {
    _loggerProxy2.default.logger.info('Roap:util#setRemoteDescription --> Success for correlationId: ' + meeting.correlationId);

    return {
      seq: session.ANSWER.seq,
      locusId: meeting.locusId,
      locusSelfId: meeting.locusInfo.self.id,
      mediaId: meeting.mediaId,
      correlationId: meeting.correlationId
    };
  }).catch(function (err) {
    _loggerProxy2.default.logger.error('Roap:util#setRemoteDescription --> ' + err);
    throw err;
  });
};

exports.default = RoapUtil;
//# sourceMappingURL=util.js.map
