'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _map2 = require('babel-runtime/core-js/map');

var _map3 = _interopRequireDefault(_map2);

var _uniq2 = require('lodash/uniq');

var _uniq3 = _interopRequireDefault(_uniq2);

var _pick2 = require('lodash/pick');

var _pick3 = _interopRequireDefault(_pick2);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _merge2 = require('lodash/merge');

var _merge3 = _interopRequireDefault(_merge2);

var _map4 = require('lodash/map');

var _map5 = _interopRequireDefault(_map4);

var _last2 = require('lodash/last');

var _last3 = _interopRequireDefault(_last2);

var _isString2 = require('lodash/isString');

var _isString3 = _interopRequireDefault(_isString2);

var _isObject2 = require('lodash/isObject');

var _isObject3 = _interopRequireDefault(_isObject2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _defaults2 = require('lodash/defaults');

var _defaults3 = _interopRequireDefault(_defaults2);

var _cloneDeepWith2 = require('lodash/cloneDeepWith');

var _cloneDeepWith3 = _interopRequireDefault(_cloneDeepWith2);

var _cloneDeep2 = require('lodash/cloneDeep');

var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);

var _querystring = require('querystring');

var _querystring2 = _interopRequireDefault(_querystring);

var _events = require('events');

var _hmacSha = require('crypto-js/hmac-sha256');

var _hmacSha2 = _interopRequireDefault(_hmacSha);

var _encHex = require('crypto-js/enc-hex');

var _encHex2 = _interopRequireDefault(_encHex);

var _common = require('@webex/common');

var _webexCore = require('@webex/webex-core');

var _helperImage = require('@webex/helper-image');

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

var _convoError = require('./convo-error');

var _shareActivity = require('./share-activity');

var _shareActivity2 = _interopRequireDefault(_shareActivity);

var _constants = require('./constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CLUSTER_SERVICE = process.env.WEBEX_CONVERSATION_CLUSTER_SERVICE || _constants.DEFAULT_CLUSTER_SERVICE; /*!
                                                                                                             * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
                                                                                                             */

var DEFAULT_CLUSTER_IDENTIFIER = process.env.WEBEX_CONVERSATION_DEFAULT_CLUSTER || _constants.DEFAULT_CLUSTER + ':' + CLUSTER_SERVICE;

var idToUrl = new _map3.default();

var getConvoLimit = function getConvoLimit() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var limit = void 0;

  if (options.conversationsLimit) {
    limit = {
      value: options.conversationsLimit,
      name: 'conversationsLimit'
    };
  }

  return limit;
};

var Conversation = _webexCore.WebexPlugin.extend({
  namespace: 'Conversation',

  /**
   * @param {String} cluster the cluster containing the id
   * @param {UUID} [id] the id of the conversation.
   *  If empty, just return the base URL.
   * @returns {String} url of the conversation
   */
  getUrlFromClusterId: function getUrlFromClusterId() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$cluster = _ref.cluster,
        cluster = _ref$cluster === undefined ? 'us' : _ref$cluster,
        id = _ref.id;

    var clusterId = cluster === 'us' ? DEFAULT_CLUSTER_IDENTIFIER : cluster;

    // Determine if cluster has service name (non-US clusters from hydra do not)
    if (clusterId.split(':').length < 4) {
      // Add Service to cluster identifier
      clusterId = cluster + ':' + CLUSTER_SERVICE;
    }

    var _ref2 = this.webex.internal.services.getServiceFromClusterId({ clusterId: clusterId }) || {},
        url = _ref2.url;

    if (!url) {
      throw Error('Could not find service for cluster [' + cluster + ']');
    }

    return id ? url + '/conversations/' + id : url;
  },


  /**
   * @param {Object} conversation
   * @param {Object} object
   * @param {Object} activity
   * @returns {Promise}
   */
  acknowledge: function acknowledge(conversation, object, activity) {
    var _this = this;

    var url = this.getConvoUrl(conversation);
    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: url });

    if (!(0, _isObject3.default)(object)) {
      return _promise2.default.reject(new Error('`object` must be an object'));
    }

    return this.prepare(activity, {
      verb: 'acknowledge',
      target: this.prepareConversation(convoWithUrl),
      object: {
        objectType: 'activity',
        id: object.id,
        url: object.url
      }
    }).then(function (a) {
      return _this.submit(a);
    });
  },


  /**
   * Adds a participant to a conversation
   * @param {Object} conversation
   * @param {Object|string} participant
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @returns {Promise<Activity>}
   */
  add: function add(conversation, participant, activity) {
    var _this2 = this;

    var url = this.getConvoUrl(conversation);
    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: url });

    return this.webex.internal.user.asUUID(participant, { create: true }).then(function (id) {
      return _this2.prepare(activity, {
        verb: 'add',
        target: _this2.prepareConversation(convoWithUrl),
        object: {
          id: id,
          objectType: 'person'
        },
        kmsMessage: {
          method: 'create',
          uri: '/authorizations',
          resourceUri: '<KRO>',
          userIds: [id]
        }
      }).then(function (a) {
        return _this2.submit(a);
      });
    });
  },


  /**
   * Creates a conversation
   * @param {Object} params
   * @param {Array<Participant>} params.participants
   * @param {Array<File>} params.files
   * @param {string} params.comment
   * @param {string} params.html
   * @param {Object} params.displayName
   * @param {Object} options
   * @param {Boolean} options.allowPartialCreation
   * @param {Boolean} options.forceGrouped
   * @param {Boolean} options.skipOneOnOneFetch skips checking 1:1 exists before creating conversation
   * @returns {Promise<Conversation>}
   */
  create: function create(params) {
    var _this3 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!params.participants || params.participants.length === 0) {
      return _promise2.default.reject(new Error('`params.participants` is required'));
    }

    return _promise2.default.all(params.participants.map(function (participant) {
      return _this3.webex.internal.user.asUUID(participant, { create: true })
      // eslint-disable-next-line arrow-body-style
      .catch(function (err) {
        return options.allowPartialCreation ? undefined : _promise2.default.reject(err);
      });
    })).then(function (participants) {
      participants.unshift(_this3.webex.internal.device.userId);
      participants = (0, _uniq3.default)(participants);

      var validParticipants = participants.filter(function (participant) {
        return participant;
      });

      params.participants = validParticipants;

      // check if original participants list was to create a 1:1
      if (participants.length === 2 && !(options && options.forceGrouped)) {
        if (!params.participants[1]) {
          return _promise2.default.reject(new _convoError.InvalidUserCreation());
        }

        if (options.skipOneOnOneFetch) {
          return _this3._createOneOnOne(params);
        }

        return _this3._maybeCreateOneOnOneThenPost(params, options);
      }

      return _this3._createGrouped(params, options);
    }).then(function (c) {
      idToUrl.set(c.id, c.url);

      if (!params.files) {
        return c;
      }

      return _this3.webex.internal.conversation.share(c, params.files).then(function (a) {
        c.activities.items.push(a);

        return c;
      });
    });
  },


  /**
   * @private
   * generate a deterministic HMAC for a reaction
   * @param {Object} displayName displayName of reaction we are sending
   * @param {Object} parent parent activity of reaction
   * @returns {Promise<HMAC>}
   */
  createReactionHmac: function createReactionHmac(displayName, parent) {
    // not using webex.internal.encryption.getKey() because the JWK it returns does not have a 'k'
    // property. we need jwk.k to correctly generate the HMAC

    return this.webex.internal.encryption.unboundedStorage.get(parent.encryptionKeyUrl).then(function (keyString) {
      var key = JSON.parse(keyString);
      // when we stringify this object, keys must be in this order to generate same HMAC as
      // desktop clients
      var formatjwk = { k: key.jwk.k, kid: key.jwk.kid, kty: key.jwk.kty };

      var source = '' + (0, _stringify2.default)(formatjwk) + parent.id + displayName;

      var hmac = _encHex2.default.stringify((0, _hmacSha2.default)(source, parent.id));

      return _promise2.default.resolve(hmac);
    });
  },


  /**
   * @typedef {Object} ReactionPayload
   * @property {Object} actor
   * @property {string} actor.objectType
   * @property {string} actor.id
   * @property {string} objectType
   * @property {string} verb will be either add' or 'delete'
   * @property {Object} target
   * @property {string} target.id
   * @property {string} target.objectType
   * @property {Object} object this will change on delete vs. add
   * @property {string} object.id present in delete case
   * @property {string} object.objectType 'activity' in delete case, 'reaction2' in add case
   * @property {string} object.displayName must be 'celebrate', 'heart', 'thumbsup', 'smiley', 'haha', 'confused', 'sad'
   * @property {string} object.hmac
   */

  /**
   * @private
   * send add or delete reaction to convo service
   * @param {Object} conversation
   * The payload to send a reaction
   * @param {ReactionPayload} reactionPayload
   * @returns {Promise<Activity>}
   */
  sendReaction: function sendReaction(conversation, reactionPayload) {
    var _this4 = this;

    var url = this.getConvoUrl(conversation);
    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: url });

    if (!(0, _isObject3.default)(reactionPayload)) {
      return _promise2.default.reject(new Error('`object` must be an object'));
    }

    return this.prepare(reactionPayload, {
      target: this.prepareConversation(convoWithUrl),
      object: (0, _pick3.default)(reactionPayload, 'id', 'url', 'objectType')
    }).then(function (act) {
      return _this4.submit(act);
    });
  },


  /**
   * delete a reaction
   * @param {Object} conversation
   * @param {Object} reactionId
   * @returns {Promise<Activity>}
   */
  deleteReaction: function deleteReaction(conversation, reactionId) {
    var deleteReactionPayload = {
      actor: { objectType: 'person', id: this.webex.internal.device.userId },
      object: {
        id: reactionId,
        objectType: 'activity'
      },
      objectType: 'activity',
      target: {
        id: conversation.id,
        objectType: 'conversation'
      },
      verb: 'delete'
    };

    return this.sendReaction(conversation, deleteReactionPayload);
  },


  /**
   * create a reaction
   * @param {Object} conversation
   * @param {Object} displayName must be 'celebrate', 'heart', 'thumbsup', 'smiley', 'haha', 'confused', 'sad'
   * @param {Object} activity activity object from convo we are reacting to
   * @returns {Promise<Activity>}
   */
  addReaction: function addReaction(conversation, displayName, activity) {
    var _this5 = this;

    return this.createReactionHmac(displayName, activity).then(function (hmac) {
      var addReactionPayload = {
        actor: { objectType: 'person', id: _this5.webex.internal.device.userId },
        target: {
          id: conversation.id,
          objectType: 'conversation'
        },
        verb: 'add',
        objectType: 'activity',
        parent: {
          type: 'reaction',
          id: activity.id
        },
        object: {
          objectType: 'reaction2',
          displayName: displayName,
          hmac: hmac
        }
      };

      return _this5.sendReaction(conversation, addReactionPayload);
    });
  },


  /**
   * delete content
   * @param {Object} conversation
   * @param {Object} object
   * @param {Object} activity
   * @returns {Promise}
   */
  delete: function _delete(conversation, object, activity) {
    var _this6 = this;

    var url = this.getConvoUrl(conversation);
    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: url });

    if (!(0, _isObject3.default)(object)) {
      return _promise2.default.reject(new Error('`object` must be an object'));
    }

    return this.prepare(activity, {
      verb: 'delete',
      target: this.prepareConversation(convoWithUrl),
      object: (0, _pick3.default)(object, 'id', 'url', 'objectType')
    }).then(function (a) {
      return _this6.submit(a);
    });
  },


  /**
   * Downloads the file specified in item.scr or item.url
   * @param {Object} item
   * @param {Object} item.scr
   * @param {string} item.url
   * @param {Object} options
   * @param {Object} options.headers
   * @param {boolean} options.shouldNotAddExifData
   * @returns {Promise<File>}
   */
  download: function download(item) {
    var _this7 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var isEncrypted = Boolean(item.scr && item.scr.key);
    var shunt = new _events.EventEmitter();
    var promise = void 0;

    if (isEncrypted) {
      promise = this.webex.internal.encryption.download(item.scr, item.options);
    } else if (item.scr && item.scr.loc) {
      promise = this._downloadUnencryptedFile(item.scr.loc, options);
    } else {
      promise = this._downloadUnencryptedFile(item.url, options);
    }

    promise = promise.on('progress', function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return shunt.emit.apply(shunt, ['progress'].concat(args));
    }).then(function (res) {
      if (options.shouldNotAddExifData) {
        return res;
      }

      return (0, _helperImage.readExifData)(item, res);
    }).then(function (file) {
      _this7.logger.info('conversation: file downloaded');

      if (item.displayName && !file.name) {
        file.name = item.displayName;
      }

      if (!file.type && item.mimeType) {
        file.type = item.mimeType;
      }

      return file;
    });

    (0, _common.proxyEvents)(shunt, promise);

    return promise;
  },


  /**
   * Downloads an unencrypted file
   * @param {string} uri
   * @param {Object} options
   * @param {Ojbect} options.headers
   * @returns {Promise<File>}
   */
  _downloadUnencryptedFile: function _downloadUnencryptedFile(uri) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    (0, _assign2.default)(options, {
      uri: uri,
      responseType: 'buffer'
    });

    var promise = this.request(options).then(function (res) {
      return res.body;
    });

    (0, _common.proxyEvents)(options.download, promise);

    return promise;
  },


  /**
   * Helper method that expands a set of parameters into an activty object
   * @param {string} verb
   * @param {Object} object
   * @param {Object} target
   * @param {Object|string} actor
   * @returns {Object}
   */
  expand: function expand(verb, object, target, actor) {
    var activity = {
      actor: actor,
      objectType: 'activity',
      verb: verb
    };

    if (!actor) {
      actor = this.webex.internal.device.userId;
    }

    if ((0, _isString3.default)(actor)) {
      activity.actor = {
        objectType: 'person',
        id: actor
      };
    }

    if (object) {
      activity.object = object;
    }

    if (target) {
      activity.target = target;
    }

    return activity;
  },


  /**
  * Gets an array of activities with an array of activity URLS
  * @param {Array} activityUrls
  * @param {Object} options
  * @param {String} options.cluster cluster where the activities are located
  * @param {String} options.url base convo url where the activities are located
  * @returns {Promise<Object>} Resolves with the activities
  */
  bulkActivitiesFetch: function bulkActivitiesFetch(activityUrls) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var cluster = void 0,
        url = void 0;

    if (typeof options === 'string') {
      cluster = options;
    } else {
      cluster = options.cluster;
      url = options.url;
    }

    var resource = 'bulk_activities_fetch';
    var params = {
      method: 'POST',
      body: {
        activityUrls: activityUrls
      }
    };

    if (url) {
      var uri = url + '/' + resource;

      (0, _assign2.default)(params, {
        uri: uri
      });
    } else if (cluster) {
      var _uri = this.getUrlFromClusterId({ cluster: cluster }) + '/' + resource;

      (0, _assign2.default)(params, {
        uri: _uri
      });
    } else {
      (0, _assign2.default)(params, {
        api: 'conversation',
        resource: resource
      });
    }

    return this.webex.request(params).then(function (res) {
      var activitiesArr = [];

      if (res.body.multistatus) {
        res.body.multistatus.forEach(function (statusData) {
          if (statusData.status === '200' && statusData.data && statusData.data.activity) {
            activitiesArr.push(statusData.data.activity);
          }
        });
      }

      return activitiesArr;
    });
  },


  /**
   * Fetches a single conversation
   * @param {Object} conversation
   * @param {String} [conversation.url] The URL where the conversation is located.
   * @param {String|UUID} [conversation.user] The user to look up in the conversation service
   *   If specified, the user lookup will take precedence over the url lookup
   * @param {Object} options
   * @returns {Promise<Conversation>}
   */
  get: function get(conversation) {
    var _this8 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var user = conversation.user;

    var uri = void 0;

    try {
      uri = !user ? this.getConvoUrl(conversation) : '';
    } catch (err) {
      return _promise2.default.reject(Error(err));
    }

    var params = {
      qs: (0, _assign2.default)({
        uuidEntryFormat: true,
        personRefresh: true,
        activitiesLimit: 0,
        includeConvWithDeletedUserUUID: false,
        includeParticipants: false
      }, (0, _omit3.default)(options, 'id', 'user', 'url'))
    };

    // Default behavior is to set includeParticipants=false,
    // which makes the payload lighter by removing participant info.
    // If the caller explicitly sets the participantAckFilter or
    // participantsLimit, we don't want that default setting.
    if ('participantAckFilter' in options || 'participantsLimit' in options) {
      delete params.qs.includeParticipants;
    }

    return _promise2.default.resolve(user ? this.webex.internal.user.asUUID(user) : null).then(function (userId) {
      if (userId) {
        (0, _assign2.default)(params, {
          service: 'conversation',
          resource: 'conversations/user/' + userId
        });
      } else {
        params.uri = uri;
      }

      return _this8.request(params);
    }).then((0, _common.tap)(function (_ref3) {
      var body = _ref3.body;
      var id = body.id,
          url = body.url;


      _this8._recordUUIDs(body);
      idToUrl.set(id, url);
    })).then(function (res) {
      return res.body;
    });
  },


  /**
   * Leaves the conversation or removes the specified user from the specified
   * conversation
   * @param {Object} conversation
   * @param {Object|string} participant If not specified, defaults to current
   * user
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @returns {Promise<Activity>}
   */
  leave: function leave(conversation, participant, activity) {
    var _this9 = this;

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return _promise2.default.resolve().then(function () {
      if (!participant) {
        participant = _this9.webex.internal.device.userId;
      }

      return _this9.webex.internal.user.asUUID(participant).then(function (id) {
        return _this9.prepare(activity, {
          verb: 'leave',
          target: _this9.prepareConversation(convoWithUrl),
          object: {
            id: id,
            objectType: 'person'
          },
          kmsMessage: {
            method: 'delete',
            uri: '<KRO>/authorizations?' + _querystring2.default.stringify({ authId: id })
          }
        });
      });
    }).then(function (a) {
      return _this9.submit(a);
    });
  },


  /**
   * Lists a set of conversations. By default does not fetch activities or
   * participants
   * @param {Object} options
   * @param {boolean} options.deferDecrypt - when true, deferDecrypt tells the
   * payload transformer to normalize (but not decrypt) each received
   * conversation. Instead, the received conversations will each have a bound
   * decrypt method that can be executed at the consumer's leisure
   * @returns {Promise<Array<Conversation>>}
   */
  list: function list() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    return this._list({
      service: 'conversation',
      resource: 'conversations',
      qs: (0, _omit3.default)(options, 'deferDecrypt'),
      deferDecrypt: options.deferDecrypt,
      limit: getConvoLimit(options)
    }).then(function (results) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(results), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var convo = _step.value;

          idToUrl.set(convo.id, convo.url);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return results;
    });
  },


  /**
   * Paginates through a set of conversations. By default does not fetch activities or
   * participants
   * @param {Object} options
   * @param {boolean} options.deferDecrypt - when true, deferDecrypt tells the
   * payload transformer to normalize (but not decrypt) each received
   * conversation. Instead, the received conversations will each have a bound
   * decrypt method that can be executed at the consumer's leisure
   * @param {Page} options.page - After the first result has been returned to a consumer,
   * you can pass the Page back to the sdk to get the next list of results.
   * @returns {Promise<Array<Conversation>>}
   */
  paginate: function () {
    var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
      var _this10 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var queryOptions, reqOptions;
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!options.page) {
                _context.next = 4;
                break;
              }

              if (!(!options.page.links || !options.page.links.next)) {
                _context.next = 3;
                break;
              }

              throw new Error('No link to follow for the provided page');

            case 3:
              return _context.abrupt('return', this.request({
                url: options.page.links.next
              }).then(function (res) {
                return { page: new _webexCore.Page(res, _this10.webex) };
              }));

            case 4:

              // No page - so this is the first request to kick off the pagination process
              queryOptions = (0, _assign2.default)({
                personRefresh: true,
                uuidEntryFormat: true,
                activitiesLimit: 0,
                participantsLimit: 0,
                paginate: true
              }, (0, _omit3.default)(options, ['deferDecrypt', 'url']));
              reqOptions = {
                qs: queryOptions,
                deferDecrypt: options.deferDecrypt,
                limit: getConvoLimit(options)
              };

              // if options.url is present we likely received one or more additional urls due to federation. In this case
              // we need to initialize pagination against that url instead of the default home cluster

              if (options.url) {
                reqOptions.uri = options.url + '/conversations';
              } else {
                reqOptions.service = 'conversation';
                reqOptions.resource = 'conversations';
              }

              return _context.abrupt('return', this.request(reqOptions).then(function (res) {
                var response = {
                  page: new _webexCore.Page(res, _this10.webex)
                };

                if (res.body && res.body.additionalUrls) {
                  response.additionalUrls = res.body.additionalUrls;
                }

                return response;
              }));

            case 8:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function paginate() {
      return _ref4.apply(this, arguments);
    }

    return paginate;
  }(),


  /**
   * Lists the conversations the current user has left. By default does not
   * fetch activities or participants
   * @param {Object} options
   * @returns {Promise<Array<Conversation>>}
   */
  listLeft: function listLeft(options) {
    return this._list({
      service: 'conversation',
      resource: 'conversations/left',
      qs: options,
      limit: getConvoLimit(options)
    }).then(function (results) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(results), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var convo = _step2.value;

          idToUrl.set(convo.id, convo.url);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return results;
    });
  },


  /**
   * List activities for the specified conversation
   * @param {Object} options
   * @param {String} options.conversationUrl URL to the conversation
   * @returns {Promise<Array<Activity>>}
   */
  listActivities: function listActivities(options) {
    return this._listActivities((0, _assign2.default)(options, { resource: 'activities' }));
  },


  /**
   * Lists activities in which the current user was mentioned
   * @param {Object} options
   * @returns {Promise<Array<Activity>>}
   */
  listMentions: function listMentions(options) {
    return this._list({
      service: 'conversation',
      resource: 'mentions',
      qs: (0, _omit3.default)(options, 'mentions')
    });
  },


  /**
   * Mutes the mentions of a conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  muteMentions: function muteMentions(conversation, activity) {
    return this.tag(conversation, {
      tags: ['MENTION_NOTIFICATIONS_OFF']
    }, activity);
  },


  /**
   * Mutes the messages of a conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  muteMessages: function muteMessages(conversation, activity) {
    return this.tag(conversation, {
      tags: ['MESSAGE_NOTIFICATIONS_OFF']
    }, activity);
  },


  /**
   * @param {Object} conversation
   * @param {Object} inputs
   * @param {Object} parentActivity
   * @param {Object} activity
   * @returns {Promise}
   */
  cardAction: function cardAction(conversation, inputs, parentActivity) {
    var _this11 = this;

    var activity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    activity.parent = {
      id: parentActivity.id,
      type: 'cardAction'
    };

    return this.prepare(activity, {
      verb: 'cardAction',
      target: this.prepareConversation(convoWithUrl),
      object: (0, _assign2.default)({ objectType: 'submit' }, inputs)
    }).then(function (a) {
      return _this11.submit(a);
    });
  },


  /**
   * Posts a message to a conversation
   * @param {Object} conversation
   * @param {Object|string} message if string, treated as plaintext; if object,
   * assumed to be object property of `post` activity
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @returns {Promise<Activity>}
   */
  post: function post(conversation, message, activity) {
    var _this12 = this;

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    if ((0, _isString3.default)(message)) {
      message = {
        displayName: message
      };
    }

    return this.prepare(activity, {
      verb: 'post',
      target: this.prepareConversation(convoWithUrl),
      object: (0, _assign2.default)({ objectType: 'comment' }, message)
    }).then(function (a) {
      return _this12.submit(a);
    });
  },
  prepareConversation: function prepareConversation(conversation) {
    return (0, _defaults3.default)((0, _pick3.default)(conversation, 'id', 'url', 'objectType', 'defaultActivityEncryptionKeyUrl', 'kmsResourceObjectUrl'), {
      objectType: 'conversation'
    });
  },
  prepare: function prepare(activity, params) {
    var _this13 = this;

    params = params || {};
    activity = activity || {};

    return _promise2.default.resolve(activity.prepare ? activity.prepare(params) : activity).then(function (act) {
      (0, _defaults3.default)(act, {
        verb: params.verb,
        kmsMessage: params.kmsMessage,
        objectType: 'activity',
        clientTempId: _uuid2.default.v4(),
        actor: _this13.webex.internal.device.userId
      });

      // Workaround because parent is a reserved props in Ampersand
      if (activity.parentActivityId && activity.activityType || activity.parent && activity.parent.id && activity.parent.type) {
        act.parent = {
          id: activity.parentActivityId || activity.parent.id,
          type: activity.activityType || activity.parent.type
        };
      }

      if ((0, _isString3.default)(act.actor)) {
        act.actor = {
          objectType: 'person',
          id: act.actor
        };
      }

      ['actor', 'object'].forEach(function (key) {
        if (params[key]) {
          act[key] = act[key] || {};
          (0, _defaults3.default)(act[key], params[key]);
        }
      });

      if (params.target) {
        (0, _merge3.default)(act, {
          target: (0, _pick3.default)(params.target, 'id', 'url', 'objectType', 'kmsResourceObjectUrl', 'defaultActivityEncryptionKeyUrl')
        });
      }

      ['object', 'target'].forEach(function (key) {
        if (act[key] && act[key].url && !act[key].id) {
          act[key].id = act[key].url.split('/').pop();
        }
      });

      ['actor', 'object', 'target'].forEach(function (key) {
        if (act[key] && !act[key].objectType) {
          // Reminder: throwing here because it's the only way to get out of
          // this loop in event of an error.
          throw new Error('`act.' + key + '.objectType` must be defined');
        }
      });

      if (act.object && act.object.content && !act.object.displayName) {
        return _promise2.default.reject(new Error('Cannot submit activity object with `content` but no `displayName`'));
      }

      return act;
    });
  },


  /**
   * Handles incoming conversation.activity mercury messages
   * @param {Event} event
   * @returns {Promise}
   */
  processActivityEvent: function processActivityEvent(event) {
    return this.webex.transform('inbound', event).then(function () {
      return event;
    });
  },


  /**
   * Removes all mute-related tags
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  removeAllMuteTags: function removeAllMuteTags(conversation, activity) {
    return this.untag(conversation, {
      tags: ['MENTION_NOTIFICATIONS_OFF', 'MENTION_NOTIFICATIONS_ON', 'MESSAGE_NOTIFICATIONS_OFF', 'MESSAGE_NOTIFICATIONS_ON']
    }, activity);
  },


  /**
   * Creates a ShareActivty for the specified conversation
   * @param {Object} conversation
   * @param {Object} activity
   * @returns {ShareActivty}
   */
  makeShare: function makeShare(conversation, activity) {
    // if we pass activity as null then it does not take care of the
    // clientTempId created by the web-client while making the provisional
    // activity, hence we need to pass the activity which was created by the
    // web-client. This fixes the issue where the image activities do not come
    // back properly oriented from the server since the clientTempId is missing
    return _shareActivity2.default.create(conversation, activity, this.webex);
  },


  /**
   * Assigns an avatar to a room
   * @param {Object} conversation
   * @param {File} avatar
   * @returns {Promise<Activity>}
   */
  assign: function assign(conversation, avatar) {
    var _this14 = this;

    if ((avatar.size || avatar.length) > 1024 * 1024) {
      return _promise2.default.reject(new Error('Room avatars must be less than 1MB'));
    }

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return _promise2.default.resolve().then(function () {
      var activity = _shareActivity2.default.create(conversation, null, _this14.webex);

      activity.enableThumbnails = false;
      activity.add(avatar);

      return _this14.prepare(activity, {
        target: _this14.prepareConversation(convoWithUrl)
      });
    }).then(function (a) {
      // yes, this seems a little hacky; will likely be resolved as a result
      // of #213
      a.verb = 'assign';

      return _this14.submit(a);
    });
  },


  /**
   * Get url from convo object. If there isn't one, get it from the cache
   *
   * @param {String} url The location of the conversation
   * @param {UUID} id If there is no url, fall back to id to lookup in cache or with cluster
   * @param {String} cluster Used with id to lookup url
   * @param {UUID} generalConversationUuid If this is a team, the id of the general conversation
   * @param {Object} conversations If this is a team, the list of conversations in the team
   * @returns {String} url for the specific convo
   */
  getConvoUrl: function getConvoUrl(_ref5) {
    var id = _ref5.id,
        url = _ref5.url,
        cluster = _ref5.cluster,
        conversations = _ref5.conversations,
        generalConversationUuid = _ref5.generalConversationUuid;

    if (generalConversationUuid) {
      // This is a Team
      // Because Convo doesn't have an endpoint for the team URL
      // we have to use the general convo URL.
      var generalConvo = conversations.items.find(function (convo) {
        return convo.id === generalConversationUuid;
      });

      return generalConvo.url;
    }

    if (url) {
      return url;
    }

    if (id) {
      if (cluster) {
        return this.getUrlFromClusterId({ cluster: cluster, id: id });
      }
      this.logger.warn('You should be using the `url` instead of the `id` property');
      var relatedUrl = idToUrl.get(id);

      if (!relatedUrl) {
        throw Error('Could not find the `url` from the given `id`');
      }

      return relatedUrl;
    }

    throw Error('The space needs a `url` property');
  },


  /**
   * Sets the typing status of the current user in a conversation
   *
   * @param {Object} conversation
   * @param {Object} options
   * @param {boolean} options.typing
   * @returns {Promise}
   */
  updateTypingStatus: function updateTypingStatus(conversation, options) {
    if (!conversation.id) {
      if (conversation.url) {
        conversation.id = conversation.url.split('/').pop();
      } else {
        return _promise2.default.reject(new Error('conversation: could not identify conversation'));
      }
    }

    var eventType = void 0;

    if (options.typing) {
      eventType = 'status.start_typing';
    } else {
      eventType = 'status.stop_typing';
    }

    var url = this.getConvoUrl(conversation);
    var resource = 'status/typing';
    var params = {
      method: 'POST',
      body: {
        conversationId: conversation.id,
        eventType: eventType
      },
      url: url + '/' + resource
    };

    return this.request(params);
  },


  /**
   * Shares files to the specified conversation
   * @param {Object} conversation
   * @param {ShareActivity|Array<File>} activity
   * @returns {Promise<Activity>}
   */
  share: function share(conversation, activity) {
    var _this15 = this;

    if ((0, _isArray3.default)(activity)) {
      activity = {
        object: {
          files: activity
        }
      };
    }

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    if (!(activity instanceof _shareActivity2.default)) {
      activity = _shareActivity2.default.create(convoWithUrl, activity, this.webex);
    }

    return this.prepare(activity, {
      target: this.prepareConversation(convoWithUrl)
    }).then(function (a) {
      return _this15.submit(a);
    });
  },


  /**
   * Submits an activity to the conversation service
   * @param {Object} activity
   * @param {String} [endpoint] endpoint to submit activity. If empty, find in activity
   * @returns {Promise<Activity>}
   */
  submit: function submit(activity, endpoint) {
    var _this16 = this;

    var url = endpoint || this.getConvoUrl(activity.target);
    var resource = activity.verb === 'share' ? 'content' : 'activities';
    var params = {
      method: 'POST',
      body: activity,
      qs: {
        personRefresh: true
      },
      url: url + '/' + resource
    };

    if (activity.verb === 'share') {
      (0, _assign2.default)(params.qs, {
        transcode: true,
        async: false
      });
    }
    /**
    * helper to cloneDeepWith for copying instance function
    * @param {Object|String|Symbol|Array|Date} value (recursive value to clone from params)
    * @returns {Object|null}
    */
    // eslint-disable-next-line consistent-return
    var customActivityCopy = function customActivityCopy(value) {
      var files = params.body.object.files;


      if (files && value && files.items.length > 0 && value.constructor === files.items[0].scr.constructor) {
        var copySrc = (0, _cloneDeep3.default)(value);

        copySrc.toJWE = value.toJWE;
        copySrc.toJSON = value.toJSON;

        return copySrc;
      }
    };
    var cloneActivity = (0, _cloneDeepWith3.default)(params, customActivityCopy);

    // triggers user-activity to reset logout timer
    this.webex.trigger('user-activity');

    return this.request(params).then(function (res) {
      return res.body;
    }).catch(function (error) {
      // handle when key need to rotate
      if (error.body && error.body.errorCode === _constants.KEY_ROTATION_REQUIRED) {
        cloneActivity.body.target.defaultActivityEncryptionKeyUrl = null;
        _this16.request(cloneActivity);
      } else if (error.body && (error.body.errorCode === _constants.KEY_ALREADY_ROTATED || error.body.errorCode === _constants.ENCRYPTION_KEY_URL_MISMATCH)) {
        // handle when key need to update
        _this16.webex.request({
          method: 'GET',
          api: 'conversation',
          resource: 'conversations/' + params.body.target.id
        }).then(function (res) {
          cloneActivity.body.target.defaultActivityEncryptionKeyUrl = res.body.defaultActivityEncryptionkeyUrl;
          _this16.request(cloneActivity);
        });
      } else {
        throw error;
      }
    });
  },

  /**
   * Remove the avatar from a room
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise}
   */
  unassign: function unassign(conversation, activity) {
    var _this17 = this;

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return this.prepare(activity, {
      verb: 'unassign',
      target: this.prepareConversation(convoWithUrl),
      object: {
        objectType: 'content',
        files: {
          items: []
        }
      }
    }).then(function (a) {
      return _this17.submit(a);
    });
  },


  /**
   * Mutes the mentions of a conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  unmuteMentions: function unmuteMentions(conversation, activity) {
    return this.tag(conversation, {
      tags: ['MENTION_NOTIFICATIONS_ON']
    }, activity);
  },


  /**
   * Mutes the messages of a conversation
   * @param {Conversation~ConversationObject} conversation
   * @param {Conversation~ActivityObject} activity
   * @returns {Promise} Resolves with the created activity
   */
  unmuteMessages: function unmuteMessages(conversation, activity) {
    return this.tag(conversation, {
      tags: ['MESSAGE_NOTIFICATIONS_ON']
    }, activity);
  },


  /**
   * Update an existing activity
   * @param {Object} conversation
   * @param {Object} object
   * @param {Object} activity
   * @returns {Promise}
   */
  update: function update(conversation, object, activity) {
    var _this18 = this;

    if (!(0, _isObject3.default)(object)) {
      return _promise2.default.reject(new Error('`object` must be an object'));
    }

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return this.prepare(activity, {
      verb: 'update',
      target: this.prepareConversation(convoWithUrl),
      object: object
    }).then(function (a) {
      return _this18.submit(a);
    });
  },


  /**
   * Sets a new key for the conversation
   * @param {Object} conversation
   * @param {Key|string} key (optional)
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @returns {Promise<Activity>}
   */
  updateKey: function updateKey(conversation, key, activity) {
    var _this19 = this;

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return this.get(convoWithUrl, {
      activitiesLimit: 0,
      includeParticipants: true
    }).then(function (c) {
      return _this19._updateKey(c, key, activity);
    });
  },


  /**
   * Sets a new key for the conversation
   * @param {Object} conversation
   * @param {Key|string} key (optional)
   * @param {Object} activity Reference to the activity that will eventually be
   * posted. Use this to (a) pass in e.g. clientTempId and (b) render a
   * provisional activity
   * @private
   * @returns {Promise<Activity>}
   */
  _updateKey: function _updateKey(conversation, key, activity) {
    var _this20 = this;

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return _promise2.default.resolve(key || this.webex.internal.encryption.kms.createUnboundKeys({ count: 1 })).then(function (keys) {
      var k = (0, _isArray3.default)(keys) ? keys[0] : keys;
      var params = {
        verb: 'updateKey',
        target: _this20.prepareConversation(convoWithUrl),
        object: {
          defaultActivityEncryptionKeyUrl: k.uri,
          objectType: 'conversation'
        }
      };

      // Reminder: the kmsResourceObjectUrl is only usable if there is
      // defaultActivityEncryptionKeyUrl.
      // Valid defaultActivityEncryptionKeyUrl start with 'kms:'
      if (convoWithUrl.kmsResourceObjectUrl && convoWithUrl.kmsResourceObjectUrl.startsWith('kms:')) {
        params.kmsMessage = {
          method: 'update',
          resourceUri: '<KRO>',
          uri: k.uri
        };
      } else {
        params.kmsMessage = {
          method: 'create',
          uri: '/resources',
          userIds: (0, _map5.default)(convoWithUrl.participants.items, 'id'),
          keyUris: [k.uri]
        };
      }

      return _this20.prepare(activity, params).then(function (a) {
        return _this20.submit(a);
      });
    });
  },


  /**
   * @param {Object} payload
   * @param {Object} options
   * @private
   * @returns {Promise<Activity>}
   */
  _create: function _create(payload) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return this.request({
      method: 'POST',
      service: 'conversation',
      resource: 'conversations',
      body: payload,
      qs: {
        forceCreate: options.allowPartialCreation
      }
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * @param {Object} params
   * @param {Object} options
   * @private
   * @returns {Promise}
   */
  _createGrouped: function _createGrouped(params, options) {
    return this._create(this._prepareConversationForCreation(params), options);
  },


  /**
   * @param {Object} params
   * @param {Object} options
   * @private
   * @returns {Promise}
   */
  _createOneOnOne: function _createOneOnOne(params) {
    var payload = this._prepareConversationForCreation(params);

    payload.tags = ['ONE_ON_ONE'];

    return this._create(payload);
  },


  /**
   * Get the current conversation url.
   *
   * @returns {Promise<string>} - conversation url
   */
  getConversationUrl: function getConversationUrl() {
    var _this21 = this;

    this.logger.info('conversation: getting the conversation service url');

    var convoUrl = this.webex.internal.services.get('conversation');

    // Validate if the conversation url exists in the services plugin and
    // resolve with its value.
    if (convoUrl) {
      return _promise2.default.resolve(convoUrl);
    }

    // Wait for the postauth catalog to update and then try to retrieve the
    // conversation service url again.
    return this.webex.internal.waitForCatalog('postauth').then(function () {
      return _this21.webex.internal.services.get('conversation');
    }).catch(function (error) {
      _this21.logger.warn('conversation: unable to get conversation url', error.message);

      return _promise2.default.reject(error);
    });
  },


  /**
   * @param {Object} conversation
   * @private
   * @returns {Promise}
   */
  _inferConversationUrl: function _inferConversationUrl(conversation) {
    var _this22 = this;

    if (conversation.id) {
      return this.webex.internal.feature.getFeature('developer', 'web-high-availability').then(function (haMessagingEnabled) {
        if (haMessagingEnabled) {
          // recompute conversation URL each time as the host may have changed
          // since last usage
          return _this22.getConversationUrl().then(function (url) {
            conversation.url = url + '/conversations/' + conversation.id;

            return conversation;
          });
        }
        if (!conversation.url) {
          return _this22.getConversationUrl().then(function (url) {
            conversation.url = url + '/conversations/' + conversation.id;
            /* istanbul ignore else */
            if (process.env.NODE_ENV !== 'production') {
              _this22.logger.warn('conversation: inferred conversation url from conversation id; please pass whole conversation objects to Conversation methods');
            }

            return conversation;
          });
        }

        return _promise2.default.resolve(conversation);
      });
    }

    return _promise2.default.resolve(conversation);
  },


  /**
   * @param {Object} options
   * @param {String} options.conversationUrl URL to the conversation
   * @param {String} options.resource The URL resource to hit for a list of objects
   * @private
   * @returns {Promise<Array<Activity>>}
   */
  _listActivities: function _listActivities(options) {
    var id = options.conversationId;
    var url = this.getConvoUrl({ url: options.conversationUrl, id: id });
    var resource = options.resource;


    return this._list({
      qs: (0, _omit3.default)(options, 'resource'),
      url: url + '/' + resource
    });
  },


  /**
   * @param {Object} options
   * @private
   * @returns {Promise<Array<Conversation>>}
   */
  _list: function () {
    var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(options) {
      var _this23 = this;

      var res, list, limit, results, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, result, items;

      return _regenerator2.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              options.qs = (0, _assign2.default)({
                personRefresh: true,
                uuidEntryFormat: true,
                activitiesLimit: 0,
                participantsLimit: 0
              }, options.qs);

              _context2.next = 3;
              return this.request(options);

            case 3:
              res = _context2.sent;
              list = void 0;


              if (!res.body || !res.body.items || res.body.items.length === 0) {
                list = [];
              } else {
                list = res.body.items.slice(0);
                if ((0, _last3.default)(list).published < list[0].published) {
                  list.reverse();
                }
              }

              // The user has more data in another cluster.
              // Follow the 'additionalUrls' for that data.

              if (!res.body.additionalUrls) {
                _context2.next = 32;
                break;
              }

              limit = 0;

              // If the user asked for a specific amount of data,
              // don't fetch more than what was asked.
              // Here we figure out how much is left from the original request.
              // Divide that by the number of additional URLS.
              // This won't get us the exact limit but it will retrieve something
              // from every cluster listed.

              if (options.limit) {
                limit = Math.floor((options.limit.value - list.length) / res.body.additionalUrls.length);
              }

              // If the limit is 0 for some reason,
              // don't bother requesting from other clusters

              if (!(!options.limit || limit !== 0)) {
                _context2.next = 32;
                break;
              }

              _context2.next = 12;
              return _promise2.default.all(res.body.additionalUrls.map(function (host) {
                var url = host + '/' + options.resource;
                var newOptions = (0, _assign2.default)({}, options, { uri: url, url: url });

                if (options.limit) {
                  newOptions.qs[newOptions.limit.name] = limit;
                }

                return _this23.request(newOptions);
              }));

            case 12:
              results = _context2.sent;
              _iteratorNormalCompletion3 = true;
              _didIteratorError3 = false;
              _iteratorError3 = undefined;
              _context2.prev = 16;


              for (_iterator3 = (0, _getIterator3.default)(results); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                result = _step3.value;

                if (result.body && result.body.items && result.body.items.length) {
                  items = result.body.items;


                  if ((0, _last3.default)(items).published < items[0].published) {
                    items.reverse();
                  }
                  list = list.concat(items);
                }
              }
              _context2.next = 24;
              break;

            case 20:
              _context2.prev = 20;
              _context2.t0 = _context2['catch'](16);
              _didIteratorError3 = true;
              _iteratorError3 = _context2.t0;

            case 24:
              _context2.prev = 24;
              _context2.prev = 25;

              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }

            case 27:
              _context2.prev = 27;

              if (!_didIteratorError3) {
                _context2.next = 30;
                break;
              }

              throw _iteratorError3;

            case 30:
              return _context2.finish(27);

            case 31:
              return _context2.finish(24);

            case 32:
              _context2.next = 34;
              return _promise2.default.all(list.map(function (item) {
                return _this23._recordUUIDs(item);
              }));

            case 34:
              return _context2.abrupt('return', list);

            case 35:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, this, [[16, 20, 24, 32], [25,, 27, 31]]);
    }));

    function _list(_x12) {
      return _ref6.apply(this, arguments);
    }

    return _list;
  }(),


  /**
   * @param {Object} params
   * @param {Object} options
   * @private
   * @returns {Promise<Conversation>}
   */
  _maybeCreateOneOnOneThenPost: function _maybeCreateOneOnOneThenPost(params, options) {
    var _this24 = this;

    return this.get((0, _defaults3.default)({
      // the use of uniq in Conversation#create guarantees participant[1] will
      // always be the other user
      user: params.participants[1]
    }), (0, _assign2.default)(options, { includeConvWithDeletedUserUUID: true, includeParticipants: true })).then(function (conversation) {
      if (params.comment || params.html) {
        return _this24.post(conversation, { content: params.html, displayName: params.comment }).then(function (activity) {
          conversation.activities.items.push(activity);

          return conversation;
        });
      }

      return conversation;
    }).catch(function (reason) {
      if (reason.statusCode !== 404) {
        return _promise2.default.reject(reason);
      }

      return _this24._createOneOnOne(params);
    });
  },


  /**
   * @param {Object} params
   * @private
   * @returns {Object}
   */
  _prepareConversationForCreation: function _prepareConversationForCreation(params) {
    var _this25 = this;

    var payload = {
      activities: {
        items: [this.expand('create')]
      },
      objectType: 'conversation',
      kmsMessage: {
        method: 'create',
        uri: '/resources',
        userIds: (0, _cloneDeep3.default)(params.participants),
        keyUris: []
      }
    };

    if (params.displayName) {
      payload.displayName = params.displayName;
    }

    params.participants.forEach(function (participant) {
      payload.activities.items.push(_this25.expand('add', {
        objectType: 'person',
        id: participant
      }));
    });

    if (params.comment) {
      payload.activities.items.push(this.expand('post', {
        objectType: 'comment',
        content: params.html,
        displayName: params.comment
      }));
    }

    return payload;
  },


  /**
   * @param {Object} conversation
   * @private
   * @returns {Promise}
   */
  _recordUUIDs: function _recordUUIDs(conversation) {
    var _this26 = this;

    if (!conversation.participants || !conversation.participants.items) {
      return _promise2.default.resolve(conversation);
    }

    return _promise2.default.all(conversation.participants.items.map(function (participant) {
      // ROOMs or LYRA_SPACEs do not have email addresses, so there's no point attempting to
      // record their UUIDs.
      if (participant.type === 'ROOM' || participant.type === 'LYRA_SPACE') {
        return _promise2.default.resolve();
      }

      return _this26.webex.internal.user.recordUUID(participant).catch(function (err) {
        return _this26.logger.warn('Could not record uuid', err);
      });
    }));
  },
  version: '1.80.264'
});

['favorite', 'hide', 'lock', 'mute', 'unfavorite', 'unhide', 'unlock', 'unmute'].forEach(function (verb) {
  Conversation.prototype[verb] = function submitSimpleActivity(conversation, activity) {
    var _this27 = this;

    var convoWithUrl = this.prepareConversation((0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) }));

    return this.prepare(activity, {
      verb: verb,
      object: convoWithUrl,
      target: convoWithUrl
    }).then(function (a) {
      return _this27.submit(a);
    });
  };
});

['assignModerator', 'unassignModerator'].forEach(function (verb) {
  Conversation.prototype[verb] = function submitModerationChangeActivity(conversation, moderator, activity) {
    var _this28 = this;

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return _promise2.default.all([convoWithUrl, moderator ? this.webex.internal.user.asUUID(moderator) : this.webex.internal.device.userId]).then(function (_ref7) {
      var _ref8 = (0, _slicedToArray3.default)(_ref7, 2),
          c = _ref8[0],
          userId = _ref8[1];

      return _this28.prepare(activity, {
        verb: verb,
        target: _this28.prepareConversation(c),
        object: {
          id: userId,
          objectType: 'person'
        }
      });
    }).then(function (a) {
      return _this28.submit(a);
    });
  };
});

/**
 * Sets/unsets space property for convo
 * @param {Object} conversation
 * @param {string} tag
 * @param {Activity} activity
 * @returns {Promise<Activity>}
 */
['setSpaceProperty', 'unsetSpaceProperty'].forEach(function (fnName) {
  var verb = fnName.startsWith('set') ? 'set' : 'unset';

  Conversation.prototype[fnName] = function submitSpacePropertyActivity(conversation, tag, activity) {
    var _this29 = this;

    if (!(0, _isString3.default)(tag)) {
      return _promise2.default.reject(new Error('`tag` must be a string'));
    }

    var convoWithUrl = (0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) });

    return this.prepare(activity, {
      verb: verb,
      target: this.prepareConversation(convoWithUrl),
      object: {
        tags: [tag],
        objectType: 'spaceProperty'
      }
    }).then(function (a) {
      return _this29.submit(a);
    });
  };
});

['tag', 'untag'].forEach(function (verb) {
  Conversation.prototype[verb] = function submitObjectActivity(conversation, object, activity) {
    var _this30 = this;

    if (!(0, _isObject3.default)(object)) {
      return _promise2.default.reject(new Error('`object` must be an object'));
    }

    var c = this.prepareConversation((0, _assign2.default)({}, conversation, { url: this.getConvoUrl(conversation) }));

    return this.prepare(activity, {
      verb: verb,
      target: c,
      object: (0, _assign2.default)(c, object)
    }).then(function (a) {
      return _this30.submit(a);
    });
  };
});

exports.default = Conversation;
//# sourceMappingURL=conversation.js.map
