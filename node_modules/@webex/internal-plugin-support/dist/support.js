'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _defaults2 = require('lodash/defaults');

var _defaults3 = _interopRequireDefault(_defaults2);

var _webexCore = require('@webex/webex-core');

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */

var Support = _webexCore.WebexPlugin.extend({
  namespace: 'Support',

  getFeedbackUrl: function getFeedbackUrl(options) {
    options = options || {};

    return this.request({
      method: 'POST',
      api: 'conversation',
      resource: 'users/deskFeedbackUrl',
      body: (0, _defaults3.default)(options, {
        appVersion: this.config.appVersion,
        appType: this.config.appType,
        feedbackId: options.feedbackId || _uuid2.default.v4(),
        languageCode: this.config.languageCode
      })
    }).then(function (res) {
      return res.body.url;
    });
  },
  getSupportUrl: function getSupportUrl() {
    return this.webex.request({
      method: 'GET',
      api: 'conversation',
      resource: 'users/deskSupportUrl',
      qs: {
        languageCode: this.config.languageCode
      }
    }).then(function (res) {
      return res.body.url;
    });
  },
  submitLogs: function submitLogs(metadata, logs) {
    var _this = this;

    var metadataArray = this._constructFileMetadata(metadata);

    // this is really testing that Ampersand is fully ready.  once it's ready, these exist
    if (!logs && this.webex.logger.sdkBuffer && this.webex.logger.clientBuffer && this.webex.logger.buffer) {
      logs = this.webex.logger.formatLogs();
    }

    var filename = void 0;

    if (metadata.locusId && metadata.callStart) {
      filename = metadata.locusId + '_' + metadata.callStart + '.txt';
    } else {
      filename = this.webex.sessionId + '.txt';
    }

    var userId = void 0;

    return this.webex.credentials.getUserToken().catch(function () {
      return _this.webex.credentials.getClientToken();
    }).then(function () {
      var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(token) {
        var headers, initalOpts, finalOpts, options;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                headers = { authorization: token.toString() };
                initalOpts = {
                  service: 'clientLogs',
                  resource: 'logs/urls'
                };
                finalOpts = {
                  service: 'clientLogs',
                  resource: 'logs/meta'
                };
                options = (0, _defaults3.default)(initalOpts, {
                  file: logs,
                  shouldAttemptReauth: false,
                  headers: headers,
                  phases: {
                    initialize: {
                      body: {
                        file: filename
                      }
                    },
                    upload: {
                      $uri: function $uri(session) {
                        return session.tempURL;
                      }
                    },
                    finalize: (0, _defaults3.default)(finalOpts, {
                      $body: function $body(session) {
                        userId = session.userId;

                        return {
                          filename: session.logFilename,
                          data: metadataArray,
                          userId: _this.webex.internal.device.userId || session.userId
                        };
                      }
                    })
                  }
                });
                return _context.abrupt('return', _this.webex.upload(options));

              case 5:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }()).then(function (body) {
      if (userId && !body.userId) {
        body.userId = userId;
      }

      return body;
    });
  },
  _constructFileMetadata: function _constructFileMetadata(metadata) {
    var metadataArray = ['locusId', 'callStart', 'feedbackId', 'correlationId'].map(function (key) {
      if (metadata[key]) {
        return {
          key: key,
          value: metadata[key]
        };
      }

      return null;
    }).filter(function (entry) {
      return Boolean(entry);
    });

    metadataArray.push({
      key: 'trackingId',
      value: this.webex.sessionId
    });

    return metadataArray;
  },
  version: '1.80.264'
});

exports.default = Support;
//# sourceMappingURL=support.js.map
